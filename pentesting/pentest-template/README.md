---
description: Template of initial steps for pentesting
---

# Pentest Template

{% hint style="info" %}
You can find all the scripts that are used in this page [here](https://github.com/d1ch0t0my-code/Pentest/tree/master/pentesting/repository/enumeration)
{% endhint %}

{% hint style="warning" %}
The part of the commands encapsulated between the symbols '<mark style="color:orange;">**\[**</mark>' and '<mark style="color:orange;">**]**</mark>' indicates that this part of the command is optional.

The part of the commands encapsulated between the symbols '<mark style="color:yellow;">**<**</mark>' and '<mark style="color:yellow;">**>**</mark>' indicates that this part of the command is mandatory.
{% endhint %}

## Executive Summary

OS:

HOST NAME:

PORTS:

## Enumeration

### Set Temporary Variables

```bash
ip=<victim_IP>; host=<host_ip>
```

### Scans

```bash
os_identifier.py $ip > 01.os_identifier.out
```

```bash
fportscan -host=$ip > 02.1.fportscan.out
```

```bash
nmap $ip -Pn -n -T4 -p- --open --min-rate 5000 -oG 02.2.nmap_allPorts.grep
```

#### SNMP UDP

```bash
nmap $ip -Pn -sU -sV -p 161 -oN 03.nmap_-Pn_-sU_-p161.nmap
```

## Combined Nmap-Searchsploit Analysis

### **OS detecting, version detection, script scanning and traceroute on open ports**

```bash
nmap $ip -Pn -sS -A -p<FoundPorts> -oN 03.nmap_versions.nmap
```

### Vulnerability scanning in <mark style="color:red;">NON-Secure</mark> mode

```bash
nmap $ip -Pn -sS -sV --script vuln --script-args=unsafe=1 -p<FoundPorts> -oN 04.nmap_unsafe_vulns.nmap
```

{% hint style="info" %}
At this point, if yo have obtained any http/s services, proceed with the [manual enumeration of the site](./#manual-web-browsing) while the scan is finishing.

See the "[Port by port](port-by-port/)" section for options for enumeration or exploitation of each of the open ports found.
{% endhint %}

## Web Enumeration

### Basic Web Information

```bash
whatweb http://$ip[:$port]
```

```bash
curl $ip[:$port]/robots.txt -s | html2text > curl_robots.txt_-s_html2text.txt
```

### Manual Web Browsing <a href="#manual-web-browsing" id="manual-web-browsing"></a>

### Manual Web Browsing <a href="#manual-web-browsing" id="manual-web-browsing"></a>

{% hint style="info" %}
* Any page that loads from a URL type "<mark style="color:blue;">http://site.com/page.ext</mark><mark style="color:orange;">?variable=whatever</mark>" is likely to test an RFI on "?variable=http://atackermachine/file"
* Curl to pages that may be of interest (may reveal interesting information).
* Does the response change if you POST instead of GET?
{% endhint %}

## Looking for Hidden Web Applications

### Declaration of Dictionaries and Variables

```bash
statuscodes="\"200,204,301,302,307,403,500\"";
wpplugins="/usr/share/metasploit-framework/data/wordlists/wp-plugins.txt";
wpthemes="/usr/share/metasploit-framework/data/wordlists/wp-themes.txt";
rockyou="/usr/share/wordlists/rockyou.txt";
medium="/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt";
common="/usr/share/dirb/wordlists/common.txt";
custom="/usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium_and_common.txt";
cgis="/usr/share/dirb/wordlists/vulns/cgis.txt";
big="/usr/share/seclists/Discovery/Web-Content/big.txt";
ext="php,bak,old,zip,txt,tar,gz"
```

### Feroxbuster

```bash
feroxbuster -u http://$ip:$port -w $custom -o feroxbuster_$port.txt
```

### Dirb

```bash
dirb http://$ip:80 -o dirb.txt
```

### Wfuzz

#### Syntax

<mark style="color:green;">wfuzz</mark> <mark style="color:orange;">\[-f outPutFileName.txt -L -c -t 500 --hc=404]</mark> <mark style="color:green;">-w</mark> <mark style="color:yellow;">wordlist</mark> <mark style="color:green;">http://</mark><mark style="color:yellow;">$ip</mark><mark style="color:green;">/</mark><mark style="color:orange;">\[morePath/]</mark><mark style="color:green;">**FUZZ**</mark><mark style="color:green;">\\</mark>

Where:

* <mark style="color:orange;">-f</mark> → indicates the file where the output will be saved
* <mark style="color:orange;">-L</mark> → to indicate to follow the redirections
* <mark style="color:orange;">-c</mark> → colored output
* <mark style="color:orange;">-t 500</mark> → number of threads to be used, modify as required
* <mark style="color:orange;">--hc</mark> → HTML status code to be removed from output
* <mark style="color:orange;">-w</mark> → idicates the dictionary(s) to be used
* <mark style="color:orange;">FUZZ</mark> → indicates where the substitution is made (if there are several dictionaries the second would be FUZ2Z, the third FUZ3Z and so on).

{% hint style="info" %}
You can fuzz several positions at the same time <mark style="color:orange;">**with several dictionaries**</mark>, indicating them with a "-w" each, followed by a "-w"

Then reference them in the desired URL position with "<mark style="color:orange;">FUZnZ</mark>", where "n" is the number of the dictionary (2,3,4,etc.).
{% endhint %}

#### Standard Fuzzing

```bash
wfuzz -f wfuzz_medium -L -c -t 100 --hc=404 -w $medium http://$ip/FUZZ 2>/dev/null
```

#### Fuzzing with File Extensions

We create a file with the extensions to be used as a dictionary:

```bash
echo "$ext" > ext.txt | sed -i 's/,/\n/g' ext.txt
```

We fuzze with the medium dictionary and the extensions file.

```bash
wfuzz -f wfuzz_ext_medium -L -c -t 100 --hc=404 -w $medium -w ext.txt http://$ip/FUZZ.FUZ2Z 2>/dev/null
```

#### Fuzzing WordPress

```bash
wfuzz -f wfuzz_wp-plugins -L -c -t 100 --hc=404 -w $wpplugins http://$ip[/webservices/wp]/FUZZ
```

```bash
wfuzz -f wfuzz_wp-themes -L -c -t 100 --hc=404 -w $wpthemes http://$ip[/webservices/wp]/FUZZ
```

### Gobuster

```bash
gobuster dir -r -u http://$ip -t 100 -w $common -s $statuscodes -e -o gobuster_common.txt_.txt
```

```bash
gobuster dir -r -u http://$ip -t 100 -w $medium -x $ext -o gobuster_file_types_medium.txt
```

```bash
gobuster dir -r -u http://$ip -t 100 -w $big -s $statuscodes -e -o gobuster_big.txt
```

```bash
gobuster dir -r -u http://$ip -t 100 -w $cgis -s $statuscodes -e -o gobuster_cgis.txt
```

## Web Vulnerabilities Scann

{% hint style="warning" %}
&#x20;If you get errors when scanning try playing with the -timeout flag (-timeout 15).
{% endhint %}

```bash
nikto -host $ip -port 80 -C all -output nikto_-port_80.txt
```

## OpenSSL Certs

May contain mailing addresses indicating potential USERS

```bash
openssl s_client -connect $ip:443
```

## Domain Enumeration

### Virtual Hosting

{% hint style="info" %}
<mark style="color:orange;">Virtual Host Roouting:</mark> If we get a domain we define its resolution in our "/etc/hosts" file so that the calls to that URL resolve against the IP of the machine.

Sometimes we will have a hint/word that can tell us that there is a virtual host and we are back to square one. Add to '/etc/hosts/' the entry: <mark style="color:yellow;">\<hint/word></mark><mark style="color:blue;">.domain.com</mark>
{% endhint %}

### Enumeration of Subdomains

```bash
wfuzz -c -f vhostEnum.txt -Z -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u "http://$domain" -H "Host: FUZZ.$domain" [--hw 1555]
```

### NSlookup

```bash
nslookup $ip [dns-server]
```

```bash
nslookup $ip > nslookup.txt
```

```bash
nslookup $ip 10.10.10.? > nslookup_dns.txt
```

### Dig

```bash
dig [@ip-dns-server] dominio [domain System Type (mx,ns,soa,...)]
```

```bash
dig @$ip dominio.com any > dig_dns.txt
```

### Zone Transfer

<mark style="color:orange;">e.g</mark>: pi.hole, htb, or similar

```bash
dig axfr [@ip-dns-server] dominio
```

```bash
dig axfr @$ip zoneNameToTransfer > dig_zoneTransfer.txt
```

### Find Website Blocker

Change the value of the "Host:" flag in the GET request to "test", look for domain name locks in an "href" field of a link.

Change the value of the "Host:" flag in the GET request to the domain name that is being blocked.

## Hidden Information in the Files?

```
strings filename.ext       ← lists the printable character strings of an image (-n 10 for minimum length of 10 characters)
ristretto filename.ext     ← display an image
exiftool filename.ext      ← print the metadata of a file (trying to find usernames or interesting data)
binwalk filename.ext       ← extract embedded system files from a firmware image
steghide info filename.ext ← extracts information hidden in the least significant bits of an image
```
