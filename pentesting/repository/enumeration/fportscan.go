// ###################################################################
// # Script Name : Fast Port Scan
// # date        : 20201113
// # usage       : ./fportscan -host=<remote_IP> [-threads/-range]
// # Author      : Â© 2022 S4vitar
// # Author's URL: https://s4vitar.github.io/fasttcpscan-go/
// # Description : Script to check the open ports on an IP or a range
// #               of IPs
// ###################################################################

// N.B! Before you can use this script you have to compile it.

// To compile the scritp:
// GO COMPILATION:
//     $ go build -ldflags "-s -w" -o fportscan_full fportscan.go

// TO REDUCE THE WHEIGHT OF THE FINAL FILE:
//     $ upx fportscan_full -o fportscan
//     $ rm fportscan_full

package main

import (
	"os"
	"fmt"
	"flag"
	"context"
	"strings"
	"strconv"
	"log"
	"sync"
	"time"
	"net"
)

var (
	host = flag.String("host", "", "Host or IP address to scan")
	ports = flag.String("range", "1-65535", "Port range to be tested: 80,443,1-65535,1000-2000, ...")
	threads = flag.Int("threads", 900, "Number of threads to be used")
	timeout = flag.Duration("timeout", 1*time.Second, "Seconds of waiting per port")
)

func processRange(ctx context.Context, r string) chan int {
	c := make(chan int)
	done := ctx.Done()

	go func() {
		defer close(c)
		blocks := strings.Split(r, ",")

		for _, block := range blocks {
			rg := strings.Split(block, "-")
			var minPort, maxPort int
			var err error

			minPort, err = strconv.Atoi(rg[0])

			if err != nil {
				log.Print("It has not been possible to interpret the range: ", block)
				continue
			}

			if len(rg) == 1 {
				maxPort = minPort
			} else {
				maxPort, err = strconv.Atoi(rg[1])

				if err != nil {
					log.Print("It has not been possible to interpret the range: ", block)
					continue
				}
			}
			for port := minPort; port <= maxPort; port++ {
				select {
				case c <- port:
				case <-done:
					return
				}
			}
		}
	}()

	return c
}

func scanPorts(ctx context.Context, in <-chan int) chan string {
	out := make(chan string)
	done := ctx.Done()
	var wg sync.WaitGroup
	wg.Add(*threads)

	for i := 0; i < *threads; i++ {
		go func() {
			defer wg.Done()
			for {
				select {
				case port, ok := <-in:
					if !ok {
						return
					}
					s := scanPort(port)
					select {
					case out <- s:
					case <-done:
						return
					}
				case <-done:
					return
				}
			}
		}()
	}
	go func() {
		wg.Wait()
		close(out)
	}()

	return out
}

func scanPort(port int) string {
	addr := fmt.Sprintf("%s:%d", *host, port)
	conn, err := net.DialTimeout("tcp", addr, *timeout)

	if err != nil {
		return fmt.Sprintf("%d: %s", port, err.Error())
	}

	conn.Close()

	return fmt.Sprintf("%d: Open", port)
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	if len(os.Args) < 2 {
		fmt.Printf("\nNo arguments have been provided\n\n")
		flag.PrintDefaults()
		fmt.Printf("\n")
		return
	}


	flag.Parse()

	if *host == "" {
		fmt.Printf("\nThe host to be scanned has not been defined\n\n")
		flag.PrintDefaults()
		fmt.Printf("\n")
		return
	}

	fmt.Printf("\n[*] Scanning host %s (Ports: %s)\n\n", *host, *ports)
	pR := processRange(ctx, *ports)
	sP := scanPorts(ctx, pR)

	for port := range sP {
		if strings.HasSuffix(port, ": Open") {
			fmt.Println(port)
		}
	}
	fmt.Printf("\n")
}